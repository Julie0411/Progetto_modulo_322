"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _reactNative = require("react-native");
var _reactNativeGestureHandler = require("react-native-gesture-handler");
var _reactNativeReanimated = require("react-native-reanimated");
var _CalendarProvider = require("../context/CalendarProvider");
var _DragEventProvider = require("../context/DragEventProvider");
var _utils = require("../utils/utils");
const useDragEventGesture = () => {
  const {
    minuteHeight,
    columnWidthAnim,
    hourWidth,
    visibleDateUnixAnim,
    calendarData,
    columns,
    verticalListRef,
    gridListRef
  } = (0, _CalendarProvider.useCalendar)();
  const {
    isDraggingAnim,
    dragStartMinutes,
    dragStartUnix,
    roundedDragStartMinutes,
    dragStep,
    dragPosition,
    roundedDragStartUnix,
    roundedDragDuration,
    dragDuration,
    dragSelectedType,
    extraMinutes,
    initialDragState,
    isDraggingCreateAnim,
    dragX
  } = (0, _DragEventProvider.useDragEvent)();
  const initialX = (0, _reactNativeReanimated.useSharedValue)(0);
  const findNearestIndex = visibleUnix => {
    'worklet';

    let visibleIndex = calendarData.visibleDatesArray.indexOf(visibleUnix);
    if (visibleIndex === -1) {
      var _calendarData$visible;
      const nearestVisibleUnix = (0, _utils.findNearestNumber)(calendarData.visibleDatesArray, visibleUnix);
      const nearestVisibleIndex = (_calendarData$visible = calendarData.visibleDates[nearestVisibleUnix]) === null || _calendarData$visible === void 0 ? void 0 : _calendarData$visible.index;
      if (nearestVisibleIndex === undefined) {
        return undefined;
      }
      visibleIndex = nearestVisibleIndex;
    }
    return visibleIndex;
  };
  const updateDragDurationForBottom = (translationY, initialStart, initialDuration) => {
    'worklet';

    const diffMinutes = Math.floor(translationY / minuteHeight.value);
    let nextDuration = initialDuration + extraMinutes.value + diffMinutes;
    const roundedEndTime = (0, _utils.roundMinutes)(initialStart + nextDuration, dragStep);
    let nextRoundedDuration = roundedEndTime - initialStart;
    if (nextDuration < dragStep) {
      nextDuration = dragStep;
      nextRoundedDuration = dragStep;
    }
    dragDuration.value = nextDuration;
    roundedDragDuration.value = nextRoundedDuration;
  };

  /** Updates drag start and duration when dragging the top handle. */
  const updateDragDurationForTop = (translationY, initialStart, initialDuration) => {
    'worklet';

    const minStart = initialStart + (initialDuration - dragStep);
    const initialY = (initialStart + extraMinutes.value) * minuteHeight.value;
    const newY = initialY + translationY;
    let newDragStart = Math.floor(newY / minuteHeight.value);
    let roundedDragStart = (0, _utils.roundMinutes)(newDragStart, dragStep, 'floor');
    const diffMinutes = Math.floor(translationY / minuteHeight.value);
    const diffRoundedMinutes = roundedDragStart - newDragStart;
    let nextDuration = initialDuration - extraMinutes.value - diffMinutes;
    let nextRoundedDuration = nextDuration - diffRoundedMinutes;
    if (nextDuration <= dragStep) {
      newDragStart = minStart;
      roundedDragStart = minStart;
      nextDuration = dragStep;
      nextRoundedDuration = dragStep;
    }
    dragStartMinutes.value = newDragStart;
    roundedDragStartMinutes.value = roundedDragStart;
    dragDuration.value = nextDuration;
    roundedDragDuration.value = nextRoundedDuration;
  };
  const updateDragStartPosition = (translationY, initialStart) => {
    'worklet';

    const initialY = (initialStart + extraMinutes.value) * minuteHeight.value;
    const newY = initialY + translationY;
    const newDragStart = Math.floor(newY / minuteHeight.value);
    const roundedDragStart = (0, _utils.roundMinutes)(newDragStart, dragStep, 'floor');
    dragStartMinutes.value = newDragStart;
    roundedDragStartMinutes.value = roundedDragStart;
  };
  const updateDragPositionHorizontal = (translationX, initialDayUnix, initialXPosition) => {
    'worklet';

    const initialDayUnixIndex = findNearestIndex(initialDayUnix);
    const visibleIndex = findNearestIndex(visibleDateUnixAnim.value);
    if (visibleIndex === undefined || initialDayUnixIndex === undefined) {
      return;
    }
    const dayIndexOffset = initialDayUnixIndex - visibleIndex;
    const extraX = initialXPosition - dayIndexOffset * columnWidthAnim.value - hourWidth;
    const initialOffset = dayIndexOffset * columnWidthAnim.value;
    const newX = initialOffset + translationX + extraX;
    const newDragDayIndex = Math.floor(newX / columnWidthAnim.value);
    const clampedDragDayIndex = (0, _utils.clampValues)(newDragDayIndex, 0, columns - 1);
    const nextDayIndex = visibleIndex + clampedDragDayIndex;
    const targetDayUnix = calendarData.visibleDatesArray[nextDayIndex];
    if (!targetDayUnix) {
      return;
    }
    dragStartUnix.value = targetDayUnix;
    roundedDragStartUnix.value = targetDayUnix;
  };
  const gesture = _reactNativeGestureHandler.Gesture.Pan().blocksExternalGesture(verticalListRef, gridListRef).manualActivation(true).onBegin(({
    x
  }) => {
    initialX.value = x;
  }).onStart(() => {
    initialDragState.value = {
      dragStart: dragStartMinutes.value,
      dragStartUnix: dragStartUnix.value,
      dragDuration: dragDuration.value
    };
  }).onUpdate(({
    translationX,
    translationY,
    x,
    y
  }) => {
    dragPosition.value = {
      x,
      y,
      translationX,
      translationY
    };
    dragX.value = x;
    const {
      dragStart: initialStart,
      dragStartUnix: initialDayUnix,
      dragDuration: initialDuration
    } = initialDragState.value;
    if (dragSelectedType.value === 'bottom') {
      updateDragDurationForBottom(translationY, initialStart, initialDuration);
    } else if (dragSelectedType.value === 'top') {
      updateDragDurationForTop(translationY, initialStart, initialDuration);
    } else {
      updateDragStartPosition(translationY, initialStart);
      updateDragPositionHorizontal(translationX, initialDayUnix, initialX.value);
    }
  }).onEnd(() => {
    dragStartMinutes.value = (0, _reactNativeReanimated.withTiming)(roundedDragStartMinutes.value, {
      duration: 150
    });
    dragDuration.value = (0, _reactNativeReanimated.withTiming)(roundedDragDuration.value, {
      duration: 150
    });
  }).onTouchesMove((_event, state) => {
    if (isDraggingAnim.value && !isDraggingCreateAnim.value) {
      state.activate();
    } else if (_reactNative.Platform.OS === 'ios') {
      state.fail();
    }
  }).onTouchesUp(() => {
    if (isDraggingAnim.value && !isDraggingCreateAnim.value) {
      isDraggingAnim.value = false;
      dragPosition.value = {
        x: -1,
        y: -1,
        translationX: -1,
        translationY: -1
      };
    }
  });
  return gesture;
};
var _default = exports.default = useDragEventGesture;
//# sourceMappingURL=useDragEventGesture.js.map