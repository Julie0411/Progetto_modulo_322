"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useResources = exports.useRegularEvents = exports.useMonthEvents = exports.useEventCountsByWeek = exports.useAllDayEventsByDay = exports.useAllDayEvents = exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _constants = require("../constants");
var _useLazyRef = _interopRequireDefault(require("../hooks/useLazyRef"));
var _useSyncExternalStoreWithSelector = require("../hooks/useSyncExternalStoreWithSelector");
var _storeBuilder = require("../storeBuilder");
var _dateUtils = require("../utils/dateUtils");
var _eventUtils = require("../utils/eventUtils");
var _VisibleDateProvider = require("./VisibleDateProvider");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const EventsContext = /*#__PURE__*/_react.default.createContext(undefined);
const EventsProvider = ({
  pagesPerSide,
  events = [],
  children,
  timeZone,
  firstDay,
  useAllDayEvent: showAllDay,
  hideWeekDays,
  defaultOffset = 7,
  minRegularEventMinutes = 1,
  overlapType = 'no-overlap',
  minStartDifference = _constants.DEFAULT_MIN_START_DIFFERENCE,
  resources
}, ref) => {
  const eventStore = (0, _useLazyRef.default)(() => (0, _storeBuilder.createStore)({
    allDayEvents: {},
    allDayEventsByDay: {},
    regularEvents: {},
    eventCountsByDay: {},
    eventCountsByWeek: {},
    resources: undefined
  })).current;
  const currentStartDate = (0, _VisibleDateProvider.useDateChangedListener)();
  const notifyDataChanged = (0, _react.useCallback)((date, offset = defaultOffset) => {
    const zonedDate = (0, _dateUtils.forceUpdateZone)(date, timeZone);
    const minUnix = zonedDate.minus({
      days: offset * pagesPerSide
    }).toMillis();
    const maxUnix = zonedDate.plus({
      days: offset * (pagesPerSide + 1)
    }).toMillis();
    const {
      regular: regularEvents,
      allDays: allDayEvents
    } = (0, _eventUtils.filterEvents)(events, minUnix, maxUnix, showAllDay);

    // Process regular events
    const regularEventMap = new Map();
    regularEvents.forEach(event => {
      const processedEvents = (0, _eventUtils.processEventOccurrences)(event, minUnix, maxUnix, timeZone, (e, tz) => (0, _eventUtils.divideEvents)(e, tz, minRegularEventMinutes));
      processedEvents.forEach(evt => {
        const dayStart = (0, _dateUtils.parseDateTime)(evt._internal.startUnix).startOf('day').toMillis();
        if (!regularEventMap.has(dayStart)) {
          regularEventMap.set(dayStart, []);
        }
        regularEventMap.get(dayStart).push(evt);
      });
    });
    const packedRegularEvents = {};
    regularEventMap.forEach((rEvents, day) => {
      packedRegularEvents[day] = (0, _eventUtils.populateEvents)(rEvents, {
        overlap: overlapType === 'overlap',
        minStartDifference,
        resources
      });
    });

    // Process all-day events
    const allDayEventMap = new Map();
    allDayEvents.forEach(event => {
      const processedEvents = (0, _eventUtils.processEventOccurrences)(event, minUnix, maxUnix, timeZone, (e, tz) => (0, _eventUtils.divideAllDayEvents)(e, tz, firstDay, hideWeekDays));
      processedEvents.forEach(evt => {
        const weekStart = evt._internal.weekStart;
        if (!weekStart) {
          return;
        }
        if (!allDayEventMap.has(weekStart)) {
          allDayEventMap.set(weekStart, []);
        }
        allDayEventMap.get(weekStart).push(evt);
      });
    });
    const {
      packedAllDayEvents,
      packedAllDayEventsByDay,
      eventCountsByWeek,
      eventCountsByDay
    } = (0, _eventUtils.processAllDayEventMap)(allDayEventMap, timeZone, hideWeekDays);
    eventStore.setState({
      regularEvents: packedRegularEvents,
      allDayEvents: packedAllDayEvents,
      allDayEventsByDay: packedAllDayEventsByDay,
      eventCountsByDay,
      eventCountsByWeek,
      resources
    });
  }, [defaultOffset, timeZone, pagesPerSide, events, showAllDay, hideWeekDays, eventStore, resources, minRegularEventMinutes, overlapType, minStartDifference, firstDay]);
  (0, _react.useImperativeHandle)(ref, () => ({
    getEventsByDate: date => {
      const dateObj = (0, _dateUtils.parseDateTime)(date);
      const dateUnix = dateObj.startOf('day').toMillis();
      const regularEvents = eventStore.getState().regularEvents[dateUnix];
      if (!regularEvents) {
        return [];
      }
      const targetUnix = (0, _dateUtils.forceUpdateZone)(dateObj, timeZone).toMillis();
      const filteredEvents = regularEvents.filter(event => {
        const eventStart = (0, _dateUtils.parseDateTime)(event.start.dateTime).toMillis();
        const eventEnd = (0, _dateUtils.parseDateTime)(event.end.dateTime).toMillis();
        return eventStart <= targetUnix && eventEnd >= targetUnix;
      });
      return filteredEvents;
    }
  }));
  (0, _react.useEffect)(() => {
    notifyDataChanged(currentStartDate);
  }, [events, notifyDataChanged, currentStartDate]);
  return /*#__PURE__*/_react.default.createElement(EventsContext.Provider, {
    value: eventStore
  }, children);
};
var _default = exports.default = /*#__PURE__*/(0, _react.forwardRef)(EventsProvider);
const useAllDayEvents = (date, numberOfDays, visibleDays) => {
  const eventsContext = (0, _react.useContext)(EventsContext);
  const selectorByDate = (0, _react.useCallback)(state => {
    const data = [];
    const eventCounts = {};
    const totalDays = numberOfDays === 1 ? 1 : 7;
    for (let i = 0; i < totalDays; i++) {
      const dateUnix = (0, _dateUtils.parseDateTime)(date).plus({
        days: i
      }).toMillis();
      if (visibleDays[dateUnix]) {
        const events = state.allDayEvents[dateUnix];
        const count = state.eventCountsByDay[dateUnix];
        if (count) {
          eventCounts[dateUnix] = count;
        }
        if (events) {
          data.push(...events);
        }
      }
    }
    return {
      data,
      eventCounts
    };
  }, [date, numberOfDays, visibleDays]);
  if (!eventsContext) {
    throw new Error('useAllDayEvents must be used within a EventsProvider');
  }
  const state = (0, _useSyncExternalStoreWithSelector.useSyncExternalStoreWithSelector)(eventsContext.subscribe, eventsContext.getState, selectorByDate);
  return state;
};
exports.useAllDayEvents = useAllDayEvents;
const useAllDayEventsByDay = date => {
  const eventsContext = (0, _react.useContext)(EventsContext);
  const selectorByDate = (0, _react.useCallback)(state => {
    const events = state.allDayEventsByDay[date] ?? [];
    const eventCounts = state.eventCountsByDay[date] ?? 0;
    return {
      data: events,
      eventCounts
    };
  }, [date]);
  if (!eventsContext) {
    throw new Error('useAllDayEvents must be used within a EventsProvider');
  }
  const state = (0, _useSyncExternalStoreWithSelector.useSyncExternalStoreWithSelector)(eventsContext.subscribe, eventsContext.getState, selectorByDate);
  return state;
};
exports.useAllDayEventsByDay = useAllDayEventsByDay;
const useRegularEvents = (date, numberOfDays, visibleDays) => {
  const eventsContext = (0, _react.useContext)(EventsContext);
  const selectorByDate = (0, _react.useCallback)(state => {
    const data = [];
    const totalDays = numberOfDays === 1 ? 1 : 7;
    for (let i = 0; i < totalDays; i++) {
      const dateUnix = (0, _dateUtils.parseDateTime)(date).plus({
        days: i
      }).toMillis();
      if (visibleDays[dateUnix]) {
        const events = state.regularEvents[dateUnix];
        if (events) {
          data.push(...events);
        }
      }
    }
    return {
      data
    };
  }, [date, numberOfDays, visibleDays]);
  if (!eventsContext) {
    throw new Error('useRegularEvents must be used within a EventsProvider');
  }
  const state = (0, _useSyncExternalStoreWithSelector.useSyncExternalStoreWithSelector)(eventsContext.subscribe, eventsContext.getState, selectorByDate);
  return state;
};
exports.useRegularEvents = useRegularEvents;
const useEventCountsByWeek = type => {
  const eventsContext = (0, _react.useContext)(EventsContext);
  const selectEventCountByWeek = (0, _react.useCallback)(() => type === 'week' ? (eventsContext === null || eventsContext === void 0 ? void 0 : eventsContext.getState().eventCountsByWeek) ?? {} : (eventsContext === null || eventsContext === void 0 ? void 0 : eventsContext.getState().eventCountsByDay) ?? {}, [eventsContext, type]);
  if (!eventsContext) {
    throw new Error('useRegularEvents must be used within a EventsProvider');
  }
  const state = (0, _useSyncExternalStoreWithSelector.useSyncExternalStoreWithSelector)(eventsContext.subscribe, eventsContext.getState, selectEventCountByWeek);
  return state;
};
exports.useEventCountsByWeek = useEventCountsByWeek;
const useResources = () => {
  const eventsContext = (0, _react.useContext)(EventsContext);
  const selectResources = (0, _react.useCallback)(() => eventsContext === null || eventsContext === void 0 ? void 0 : eventsContext.getState().resources, [eventsContext]);
  if (!eventsContext) {
    throw new Error('useResources must be used within a EventsProvider');
  }
  const state = (0, _useSyncExternalStoreWithSelector.useSyncExternalStoreWithSelector)(eventsContext.subscribe, eventsContext.getState, selectResources);
  return state;
};
exports.useResources = useResources;
const useMonthEvents = (date, numberOfDays, visibleDays) => {
  const eventsContext = (0, _react.useContext)(EventsContext);
  const selectorByDate = (0, _react.useCallback)(state => {
    const data = {};
    for (let i = 0; i < numberOfDays; i++) {
      const dateUnix = (0, _dateUtils.parseDateTime)(date).plus({
        days: i
      }).toMillis();
      if (visibleDays.includes(dateUnix)) {
        const events = state.regularEvents[dateUnix];
        if (events) {
          data[dateUnix] = events;
        }
      }
    }
    return {
      data
    };
  }, [date, numberOfDays, visibleDays]);
  if (!eventsContext) {
    throw new Error('useRegularEvents must be used within a EventsProvider');
  }
  const state = (0, _useSyncExternalStoreWithSelector.useSyncExternalStoreWithSelector)(eventsContext.subscribe, eventsContext.getState, selectorByDate);
  return state;
};
exports.useMonthEvents = useMonthEvents;
//# sourceMappingURL=EventsProvider.js.map