"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useDragEventActions = exports.useDragEvent = exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _reactNativeReanimated = require("react-native-reanimated");
var _constants = require("../constants");
var _dateUtils = require("../utils/dateUtils");
var _ActionsProvider = require("./ActionsProvider");
var _CalendarProvider = require("./CalendarProvider");
var _TimeZoneProvider = require("./TimeZoneProvider");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const DragEventContext = /*#__PURE__*/_react.default.createContext(undefined);
const DragEventActionsContext = /*#__PURE__*/_react.default.createContext(undefined);
const SCROLL_THRESHOLD = 100;
const AUTO_SCROLL_INTERVAL = 800;
const AUTO_SCROLL_SPEED = 100;
const DragEventProvider = ({
  children,
  dragStep,
  allowDragToEdit,
  selectedEvent,
  allowDragToCreate,
  defaultDuration,
  hapticService,
  resources
}) => {
  // Contexts
  const {
    timeZone
  } = (0, _TimeZoneProvider.useTimezone)();
  const {
    offsetY,
    offsetX,
    scrollVisibleHeightAnim,
    gridListRef,
    hourWidth,
    columns,
    columnWidthAnim,
    columnWidth,
    calendarListRef,
    numberOfDays,
    triggerDateChanged,
    calendarData,
    scrollType,
    scrollByDay,
    timelineHeight,
    verticalListRef,
    minuteHeight,
    calendarGridWidth,
    visibleDateUnixAnim,
    visibleDateUnix,
    dayBarListRef
  } = (0, _CalendarProvider.useCalendar)();
  const {
    onDragSelectedEventStart,
    onDragSelectedEventEnd,
    onDragEventStart,
    onDragEventEnd,
    onDragCreateEventStart,
    onDragCreateEventEnd,
    onLongPressEvent
  } = (0, _ActionsProvider.useActions)();
  const isDraggingAnim = (0, _reactNativeReanimated.useSharedValue)(false);
  const [isDragging, setIsDragging] = (0, _react.useState)(false);
  const [isDraggingCreate, setIsDraggingCreate] = (0, _react.useState)(false);
  const [draggingEvent, setDraggingEvent] = (0, _react.useState)();
  const dragStartUnix = (0, _reactNativeReanimated.useSharedValue)(-1);
  const dragStartMinutes = (0, _reactNativeReanimated.useSharedValue)(-1);
  const dragDuration = (0, _reactNativeReanimated.useSharedValue)(-1);
  const roundedDragStartUnix = (0, _reactNativeReanimated.useSharedValue)(-1);
  const roundedDragStartMinutes = (0, _reactNativeReanimated.useSharedValue)(-1);
  const roundedDragDuration = (0, _reactNativeReanimated.useSharedValue)(-1);
  const dragX = (0, _reactNativeReanimated.useSharedValue)(-1);
  const extraMinutes = (0, _reactNativeReanimated.useSharedValue)(0);
  const dragSelectedType = (0, _reactNativeReanimated.useSharedValue)(undefined);
  const dragPosition = (0, _reactNativeReanimated.useSharedValue)({
    x: -1,
    y: -1,
    translationX: -1,
    translationY: -1
  });
  const initialDragState = (0, _reactNativeReanimated.useSharedValue)({
    dragStart: -1,
    dragStartUnix: -1,
    dragDuration: -1
  });
  const dragSelectedStartUnix = (0, _reactNativeReanimated.useSharedValue)(-1);
  const dragSelectedStartMinutes = (0, _reactNativeReanimated.useSharedValue)(-1);
  const dragSelectedDuration = (0, _reactNativeReanimated.useSharedValue)(-1);
  const isDraggingSelectedEvent = (0, _reactNativeReanimated.useSharedValue)(false);
  const isDraggingCreateAnim = (0, _reactNativeReanimated.useSharedValue)(false);
  const autoHScrollTimer = (0, _react.useRef)();
  const autoVScrollTimer = (0, _react.useRef)();
  const scrollTargetX = (0, _reactNativeReanimated.useSharedValue)(0);
  const offsetYAnim = (0, _reactNativeReanimated.useSharedValue)(0);
  const draggingId = (draggingEvent === null || draggingEvent === void 0 ? void 0 : draggingEvent.localId) ?? (draggingEvent === null || draggingEvent === void 0 ? void 0 : draggingEvent.id);
  const selectedEventId = (selectedEvent === null || selectedEvent === void 0 ? void 0 : selectedEvent.localId) ?? (selectedEvent === null || selectedEvent === void 0 ? void 0 : selectedEvent.id);
  const calculateNewEventTimes = () => {
    const baseDate = (0, _dateUtils.parseDateTime)(roundedDragStartUnix.value);
    const newStart = baseDate.plus({
      minutes: roundedDragStartMinutes.value
    });
    const offset = Math.abs(newStart.offset - baseDate.offset);
    const newStartUnix = newStart.toMillis() + offset * _constants.MILLISECONDS_IN_MINUTE;
    const newEndUnix = newStartUnix + roundedDragDuration.value * _constants.MILLISECONDS_IN_MINUTE;
    let resourceId = draggingEvent === null || draggingEvent === void 0 ? void 0 : draggingEvent.resourceId;
    if (resources !== null && resources !== void 0 && resources.length) {
      var _resources$resourceIn;
      const width = columnWidthAnim.value / resources.length;
      const resourceIndex = Math.floor((dragX.value - hourWidth) / width);
      resourceId = (_resources$resourceIn = resources[resourceIndex]) === null || _resources$resourceIn === void 0 ? void 0 : _resources$resourceIn.id;
    }
    return {
      newStartUnix,
      newEndUnix,
      resourceId
    };
  };
  const shouldUpdateEvent = (event, newStart, newEnd, newResourceId) => {
    var _event$start, _event$end;
    if (!(event !== null && event !== void 0 && (_event$start = event.start) !== null && _event$start !== void 0 && _event$start.dateTime) || !(event !== null && event !== void 0 && (_event$end = event.end) !== null && _event$end !== void 0 && _event$end.dateTime)) {
      return false;
    }
    const prevStart = (0, _dateUtils.parseDateTime)(event.start.dateTime, {
      zone: event.start.timeZone
    }).setZone(timeZone).toMillis();
    const prevEnd = (0, _dateUtils.parseDateTime)(event.end.dateTime, {
      zone: event.end.timeZone
    }).setZone(timeZone).toMillis();
    return prevStart !== newStart || prevEnd !== newEnd || event.resourceId !== newResourceId;
  };
  const createUpdatedEvent = (event, newStartUnix, newEndUnix, resourceId) => {
    const newStartObj = (0, _dateUtils.forceUpdateZone)(newStartUnix, timeZone);
    const newEndObj = (0, _dateUtils.forceUpdateZone)(newEndUnix, timeZone);
    const currentEvent = {
      ...event
    };
    delete currentEvent._internal;
    if (resourceId) {
      currentEvent.resourceId = resourceId;
    }
    return {
      ...currentEvent,
      start: {
        dateTime: newStartObj.toISO(),
        timeZone
      },
      end: {
        dateTime: newEndObj.toISO(),
        timeZone
      }
    };
  };
  const resetDragState = () => {
    setDraggingEvent(undefined);
    setIsDraggingCreate(false);
    (0, _reactNativeReanimated.runOnUI)(() => {
      dragStartUnix.value = -1;
      dragDuration.value = -1;
      dragStartMinutes.value = -1;
      dragSelectedType.value = undefined;
      dragX.value = -1;
      roundedDragStartUnix.value = -1;
      roundedDragStartMinutes.value = -1;
      roundedDragDuration.value = -1;
      extraMinutes.value = 0;
      isDraggingSelectedEvent.value = false;
    })();
  };
  const handleIsDraggingChange = async dragging => {
    if (!dragging) {
      _stopAutoHScroll();
      _stopAutoVScroll();
      const {
        newStartUnix,
        newEndUnix,
        resourceId
      } = calculateNewEventTimes();
      const updatedEvent = createUpdatedEvent(draggingEvent, newStartUnix, newEndUnix, resourceId);
      if (selectedEventId) {
        const shouldUpdate = shouldUpdateEvent(draggingEvent, newStartUnix, newEndUnix, resourceId);
        if (shouldUpdate) {
          await (onDragSelectedEventEnd === null || onDragSelectedEventEnd === void 0 ? void 0 : onDragSelectedEventEnd(updatedEvent));
        }
      } else if (isDraggingCreate) {
        await (onDragCreateEventEnd === null || onDragCreateEventEnd === void 0 ? void 0 : onDragCreateEventEnd(updatedEvent));
      } else {
        await (onDragEventEnd === null || onDragEventEnd === void 0 ? void 0 : onDragEventEnd(updatedEvent));
      }
      resetDragState();
    }
    setIsDragging(dragging);
  };
  (0, _reactNativeReanimated.useAnimatedReaction)(() => isDraggingAnim.value, (dragging, prevDragging) => {
    if (prevDragging !== null && dragging !== prevDragging) {
      if (dragging) {
        scrollTargetX.value = offsetX.value;
      }
      (0, _reactNativeReanimated.runOnJS)(handleIsDraggingChange)(dragging);
    }
  }, [draggingEvent === null || draggingEvent === void 0 ? void 0 : draggingEvent.start, draggingEvent === null || draggingEvent === void 0 ? void 0 : draggingEvent.end, selectedEventId]);
  const _triggerHaptic = async () => {
    try {
      await hapticService.selection();
    } catch (error) {}
  };
  (0, _reactNativeReanimated.useAnimatedReaction)(() => roundedDragStartMinutes.value, (clampedStart, prevStart) => {
    if (clampedStart !== prevStart && clampedStart !== -1) {
      (0, _reactNativeReanimated.runOnJS)(_triggerHaptic)();
    }
  });
  (0, _reactNativeReanimated.useAnimatedReaction)(() => roundedDragStartUnix.value, (unix, prevUnix) => {
    if (unix !== prevUnix && unix !== -1) {
      (0, _reactNativeReanimated.runOnJS)(_triggerHaptic)();
    }
  });
  (0, _reactNativeReanimated.useAnimatedReaction)(() => roundedDragDuration.value, (duration, prevDuration) => {
    if (duration !== prevDuration && duration !== -1) {
      (0, _reactNativeReanimated.runOnJS)(_triggerHaptic)();
    }
  });
  (0, _react.useEffect)(() => {
    var _selectedEvent$start, _selectedEvent$end;
    if (selectedEvent !== null && selectedEvent !== void 0 && (_selectedEvent$start = selectedEvent.start) !== null && _selectedEvent$start !== void 0 && _selectedEvent$start.dateTime && selectedEvent !== null && selectedEvent !== void 0 && (_selectedEvent$end = selectedEvent.end) !== null && _selectedEvent$end !== void 0 && _selectedEvent$end.dateTime) {
      const eventStart = (0, _dateUtils.parseDateTime)(selectedEvent.start.dateTime, {
        zone: selectedEvent.start.timeZone
      }).setZone(timeZone);
      const eventEnd = (0, _dateUtils.parseDateTime)(selectedEvent.end.dateTime, {
        zone: selectedEvent.end.timeZone
      }).setZone(timeZone);
      dragSelectedStartUnix.value = (0, _dateUtils.parseDateTime)(eventStart.toISODate()).toMillis();
      dragSelectedStartMinutes.value = eventStart.hour * 60 + eventStart.minute;
      dragSelectedDuration.value = eventEnd.diff(eventStart, 'minutes').minutes;
    } else {
      dragSelectedStartUnix.value = -1;
      dragSelectedStartMinutes.value = -1;
      dragSelectedDuration.value = -1;
    }
  }, [dragSelectedDuration, dragSelectedStartMinutes, dragSelectedStartUnix, selectedEvent === null || selectedEvent === void 0 ? void 0 : selectedEvent.end, selectedEvent === null || selectedEvent === void 0 ? void 0 : selectedEvent.start, timeZone]);
  const _startAutoHScroll = isNextPage => {
    var _calendarListRef$curr;
    if (autoHScrollTimer.current) {
      return;
    }
    const maxOffset = ((_calendarListRef$curr = calendarListRef.current) === null || _calendarListRef$curr === void 0 ? void 0 : _calendarListRef$curr.getMaxOffset(numberOfDays)) ?? 0;
    const shouldCancel = isNextPage ? offsetX.value === maxOffset : offsetX.value === 0;
    if (shouldCancel) {
      return;
    }
    const scrollInterval = () => {
      var _calendarListRef$curr2;
      const visibleDates = calendarData.visibleDatesArray;
      const scrollTargetDiff = Math.abs(scrollTargetX.value - offsetX.value);
      const hasScrolledToTarget = scrollTargetDiff < 2;
      if (!hasScrolledToTarget) {
        return;
      }
      const currentIndex = visibleDates.indexOf(visibleDateUnix.current);
      if (currentIndex === -1) {
        triggerDateChanged.current = undefined;
        return;
      }
      let nextVisibleDayIndex = 0;
      let nextOffset = 0;
      const reverse = isNextPage ? 1 : -1;
      if (numberOfDays === 1 || scrollByDay) {
        nextVisibleDayIndex = currentIndex + 1 * reverse;
        const colWidth = numberOfDays === 1 ? calendarGridWidth : columnWidth;
        nextOffset = nextVisibleDayIndex * colWidth;
      } else {
        nextVisibleDayIndex = currentIndex + columns * reverse;
        const pageIndex = Math.floor(nextVisibleDayIndex / columns);
        nextOffset = pageIndex * (columnWidth * columns);
      }
      const isScrollable = (_calendarListRef$curr2 = calendarListRef.current) === null || _calendarListRef$curr2 === void 0 ? void 0 : _calendarListRef$curr2.isScrollable(nextOffset, numberOfDays);
      if (!isScrollable) {
        triggerDateChanged.current = undefined;
        clearInterval(autoHScrollTimer.current);
        autoHScrollTimer.current = undefined;
        return;
      }
      const nextDateUnix = visibleDates[nextVisibleDayIndex];
      if (!nextDateUnix) {
        triggerDateChanged.current = undefined;
        return;
      }
      scrollType.current = _constants.ScrollType.calendarGrid;
      triggerDateChanged.current = nextDateUnix;
      let targetUnix = nextDateUnix;
      if (isNextPage) {
        let lastIndex = nextVisibleDayIndex + (columns - 1);
        if (numberOfDays === 1 || scrollByDay) {
          lastIndex = nextVisibleDayIndex + (numberOfDays - 1);
        }
        if (lastIndex > visibleDates.length - 1) {
          lastIndex = visibleDates.length - 1;
        }
        const lastVisibleDay = visibleDates[lastIndex];
        if (lastVisibleDay) {
          targetUnix = lastVisibleDay;
        }
      }
      (0, _reactNativeReanimated.runOnUI)(() => {
        scrollTargetX.value = nextOffset;
        if (_reactNative.Platform.OS === 'web') {
          (0, _reactNativeReanimated.scrollTo)(dayBarListRef, nextOffset, 0, true);
        }
        (0, _reactNativeReanimated.scrollTo)(gridListRef, nextOffset, 0, true);
        dragStartUnix.value = targetUnix;
        roundedDragStartUnix.value = targetUnix;
        offsetX.value = nextOffset;
      })();
    };
    autoHScrollTimer.current = setInterval(scrollInterval, AUTO_SCROLL_INTERVAL);
  };
  const _stopAutoHScroll = () => {
    if (autoHScrollTimer.current) {
      clearInterval(autoHScrollTimer.current);
      autoHScrollTimer.current = undefined;
    }
  };
  (0, _reactNativeReanimated.useAnimatedReaction)(() => dragPosition.value.x, (curX, prevX) => {
    if (isDraggingAnim.value && curX !== prevX && curX !== -1 && dragSelectedType.value !== 'top' && dragSelectedType.value !== 'bottom') {
      const isAtLeftEdge = curX <= hourWidth - 10;
      const width = columnWidthAnim.value * numberOfDays + hourWidth;
      const isAtRightEdge = width - curX <= 24;
      const isStartAutoScroll = isAtLeftEdge || isAtRightEdge;
      if (isStartAutoScroll) {
        (0, _reactNativeReanimated.runOnJS)(_startAutoHScroll)(isAtRightEdge);
      } else {
        (0, _reactNativeReanimated.runOnJS)(_stopAutoHScroll)();
      }
    }
  }, [numberOfDays, scrollByDay, columns, calendarGridWidth, columnWidth, calendarData]);
  const _startAutoVScroll = isAtTopEdge => {
    if (autoVScrollTimer.current) {
      return;
    }
    const scrollInterval = () => {
      const maxOffsetY = timelineHeight.value - scrollVisibleHeightAnim.value;
      const targetOffset = isAtTopEdge ? Math.max(0, offsetY.value - offsetYAnim.value) : Math.min(offsetY.value + offsetYAnim.value, maxOffsetY);
      (0, _reactNativeReanimated.runOnUI)(() => {
        if (targetOffset !== offsetY.value) {
          const {
            dragStart: initialStart,
            dragDuration: initialDuration
          } = initialDragState.value;
          const diffY = targetOffset - offsetY.value;
          const minutes = diffY / minuteHeight.value;
          if (dragSelectedType.value === 'bottom') {
            const nextDuration = Math.max(dragStep, dragDuration.value + minutes);
            const roundedEndMinutes = Math.round((initialStart + nextDuration) / dragStep) * dragStep;
            const roundedDuration = roundedEndMinutes - initialStart;
            dragDuration.value = nextDuration;
            roundedDragDuration.value = roundedDuration;
          } else {
            let nextStart = dragStartMinutes.value + minutes;
            let nextRoundedStart = Math.floor(nextStart / dragStep) * dragStep;
            if (dragSelectedType.value === 'top') {
              const diffRounded = nextRoundedStart - nextStart;
              const nextDuration = dragDuration.value - minutes;
              const nextRoundedDuration = nextDuration - diffRounded;
              if (nextDuration < dragStep) {
                const minStart = initialStart + (initialDuration - dragStep);
                nextStart = minStart;
                nextRoundedStart = minStart;
              }
              dragDuration.value = Math.max(dragStep, nextDuration);
              roundedDragDuration.value = Math.max(dragStep, nextRoundedDuration);
            }
            dragStartMinutes.value = nextStart;
            roundedDragStartMinutes.value = nextRoundedStart;
          }
          extraMinutes.value += minutes;
          offsetY.value = targetOffset;
          (0, _reactNativeReanimated.scrollTo)(verticalListRef, 0, targetOffset, false);
        }
      })();
      if (targetOffset === 0 || targetOffset === maxOffsetY) {
        clearInterval(autoVScrollTimer.current);
        autoVScrollTimer.current = undefined;
      }
    };
    autoVScrollTimer.current = setInterval(scrollInterval, 100);
  };
  const _stopAutoVScroll = () => {
    if (autoVScrollTimer.current) {
      clearInterval(autoVScrollTimer.current);
      autoVScrollTimer.current = undefined;
    }
  };
  (0, _reactNativeReanimated.useAnimatedReaction)(() => dragPosition.value.y, (dragY, prevY) => {
    if (isDraggingAnim.value && dragY !== prevY && dragY !== -1) {
      const isAtTopEdge = dragY <= SCROLL_THRESHOLD;
      const isAtBottomEdge = scrollVisibleHeightAnim.value - dragY <= SCROLL_THRESHOLD;
      const isStartAutoScroll = isAtBottomEdge || isAtTopEdge;
      if (isStartAutoScroll) {
        const distFromEdge = isAtTopEdge ? Math.max(0, dragY) : Math.max(0, scrollVisibleHeightAnim.value - dragY);
        const speedPct = 1 - distFromEdge / SCROLL_THRESHOLD;
        offsetYAnim.value = speedPct * AUTO_SCROLL_SPEED;
        (0, _reactNativeReanimated.runOnJS)(_startAutoVScroll)(isAtTopEdge);
      } else {
        offsetYAnim.value = 0;
        (0, _reactNativeReanimated.runOnJS)(_stopAutoVScroll)();
      }
    }
  });
  const triggerDragSelectedEvent = (0, _react.useCallback)(initialDrag => {
    if (!selectedEvent) {
      return;
    }
    if (selectedEvent && onDragSelectedEventStart) {
      onDragSelectedEventStart(selectedEvent);
    }
    setDraggingEvent(selectedEvent);
    if (resources && initialDrag.resourceIndex !== undefined && initialDrag.resourceIndex >= 0) {
      const eventWidth = columnWidth / resources.length;
      dragX.value = initialDrag.resourceIndex * eventWidth + hourWidth + 1;
    }
    (0, _reactNativeReanimated.runOnUI)(() => {
      if (initialDrag.startIndex === 0) {
        const startMinutes = dragSelectedStartMinutes.value;
        dragStartMinutes.value = startMinutes;
        roundedDragStartMinutes.value = startMinutes;
        const diffDays = Math.floor((dragSelectedStartUnix.value - visibleDateUnixAnim.value) / _constants.MILLISECONDS_IN_DAY);
        const startUnix = visibleDateUnixAnim.value + diffDays * _constants.MILLISECONDS_IN_DAY;
        dragStartUnix.value = startUnix;
        roundedDragStartUnix.value = startUnix;
      } else {
        const startByIndex = dragSelectedStartUnix.value + initialDrag.startIndex * _constants.MILLISECONDS_IN_DAY;
        const diffDays = Math.floor((startByIndex - visibleDateUnixAnim.value) / _constants.MILLISECONDS_IN_DAY);
        const startUnix = visibleDateUnixAnim.value + diffDays * _constants.MILLISECONDS_IN_DAY;
        dragStartUnix.value = startUnix;
        roundedDragStartUnix.value = startUnix;
        const originalStart = dragSelectedStartUnix.value + dragSelectedStartMinutes.value * _constants.MILLISECONDS_IN_MINUTE;
        const diffMinutes = Math.floor((startByIndex - originalStart) / _constants.MILLISECONDS_IN_MINUTE);
        dragStartMinutes.value = 0 - diffMinutes;
        roundedDragStartMinutes.value = 0 - diffMinutes;
      }
      const duration = dragSelectedDuration.value;
      dragDuration.value = duration;
      roundedDragDuration.value = duration;
      dragSelectedType.value = initialDrag.type;
      isDraggingAnim.value = true;
      isDraggingSelectedEvent.value = true;
    })();
  }, [columnWidth, dragDuration, dragSelectedDuration.value, dragSelectedStartMinutes.value, dragSelectedStartUnix.value, dragSelectedType, dragStartMinutes, dragStartUnix, dragX, hourWidth, isDraggingAnim, isDraggingSelectedEvent, onDragSelectedEventStart, resources, roundedDragDuration, roundedDragStartMinutes, roundedDragStartUnix, selectedEvent, visibleDateUnixAnim.value]);
  const triggerDragEvent = (0, _react.useCallback)((initialDrag, event) => {
    if (event && onLongPressEvent) {
      onLongPressEvent(event);
    }
    if (event && onDragEventStart) {
      onDragEventStart(event);
    }
    setDraggingEvent(event);
    dragX.value = initialDrag.dragX !== undefined ? initialDrag.dragX + hourWidth : -1;
    let startDate = (0, _dateUtils.parseDateTime)(initialDrag.start.dateTime, {
      zone: initialDrag.start.timeZone
    }).setZone(timeZone);
    let endDate = (0, _dateUtils.parseDateTime)(initialDrag.end.dateTime, {
      zone: initialDrag.end.timeZone
    }).setZone(timeZone);
    startDate = (0, _dateUtils.forceUpdateZone)(startDate);
    endDate = (0, _dateUtils.forceUpdateZone)(endDate);
    const startMinutes = startDate.hour * 60 + startDate.minute;
    const eventStartUnix = startDate.toMillis();
    const eventEndUnix = endDate.toMillis();
    (0, _reactNativeReanimated.runOnUI)(() => {
      if (initialDrag.startIndex === 0) {
        dragStartMinutes.value = startMinutes;
        roundedDragStartMinutes.value = startMinutes;
        const diffDays = Math.floor((eventStartUnix - visibleDateUnixAnim.value) / _constants.MILLISECONDS_IN_DAY);
        const startUnix = visibleDateUnixAnim.value + diffDays * _constants.MILLISECONDS_IN_DAY;
        dragStartUnix.value = startUnix;
        roundedDragStartUnix.value = startUnix;
      } else {
        const startIndex = initialDrag.startIndex ?? 0;
        const startByIndex = eventStartUnix + startIndex * _constants.MILLISECONDS_IN_DAY;
        const diffDays = Math.floor((startByIndex - visibleDateUnixAnim.value) / _constants.MILLISECONDS_IN_DAY);
        const startUnix = visibleDateUnixAnim.value + diffDays * _constants.MILLISECONDS_IN_DAY;
        dragStartUnix.value = startUnix;
        roundedDragStartUnix.value = startUnix;
        const originalStart = eventStartUnix + startMinutes * _constants.MILLISECONDS_IN_MINUTE;
        const diffMinutes = Math.floor((startByIndex - originalStart) / _constants.MILLISECONDS_IN_MINUTE);
        dragStartMinutes.value = 0 - diffMinutes;
        roundedDragStartMinutes.value = 0 - diffMinutes;
      }
      const duration = (eventEndUnix - eventStartUnix) / _constants.MILLISECONDS_IN_MINUTE;
      dragDuration.value = duration;
      roundedDragDuration.value = duration;
      isDraggingAnim.value = true;
    })();
  }, [onLongPressEvent, onDragEventStart, dragX, hourWidth, timeZone, dragDuration, roundedDragDuration, isDraggingAnim, dragStartMinutes, roundedDragStartMinutes, visibleDateUnixAnim.value, dragStartUnix, roundedDragStartUnix]);
  const triggerDragCreateEvent = (0, _react.useCallback)((date, event) => {
    var _event$nativeEvent;
    setIsDraggingCreate(true);
    dragX.value = (event === null || event === void 0 || (_event$nativeEvent = event.nativeEvent) === null || _event$nativeEvent === void 0 ? void 0 : _event$nativeEvent.locationX) !== undefined ? event.nativeEvent.locationX + hourWidth : -1;
    const start = (0, _dateUtils.parseDateTime)(date, {
      zone: timeZone
    });
    const startUnix = (0, _dateUtils.parseDateTime)(start.toISODate()).toMillis();
    const startMinutes = start.hour * 60 + start.minute;
    const roundedMinutes = Math.floor(startMinutes / dragStep) * dragStep;
    const roundedStartUnix = startUnix + roundedMinutes * _constants.MILLISECONDS_IN_MINUTE;
    const startDate = (0, _dateUtils.parseDateTime)(roundedStartUnix);
    const startISO = startDate.toISO();
    const endISO = startDate.plus({
      minutes: defaultDuration
    }).toISO();
    setDraggingEvent({
      start: {
        dateTime: startISO
      },
      end: {
        dateTime: endISO
      }
    });
    if (onDragCreateEventStart) {
      onDragCreateEventStart({
        start: {
          dateTime: startISO
        },
        end: {
          dateTime: endISO
        }
      });
    }
    (0, _reactNativeReanimated.runOnUI)(() => {
      dragStartUnix.value = startUnix;
      roundedDragStartUnix.value = startUnix;
      dragStartMinutes.value = roundedMinutes;
      roundedDragStartMinutes.value = roundedMinutes;
      dragDuration.value = defaultDuration;
      roundedDragDuration.value = defaultDuration;
      isDraggingCreateAnim.value = true;
      isDraggingAnim.value = true;
    })();
  }, [defaultDuration, dragDuration, dragStartMinutes, dragStartUnix, dragStep, dragX, hourWidth, isDraggingAnim, isDraggingCreateAnim, onDragCreateEventStart, roundedDragDuration, roundedDragStartMinutes, roundedDragStartUnix, timeZone]);
  const contextValues = (0, _react.useMemo)(() => ({
    dragStep,
    allowDragToEdit,
    isDraggingAnim,
    isDragging,
    draggingEvent,
    dragDuration,
    dragStartMinutes,
    draggingId,
    roundedDragStartMinutes,
    roundedDragDuration,
    selectedEvent,
    dragPosition,
    dragStartUnix,
    roundedDragStartUnix,
    dragSelectedStartUnix,
    dragSelectedStartMinutes,
    dragSelectedDuration,
    isDraggingSelectedEvent,
    extraMinutes,
    selectedEventId,
    dragSelectedType,
    initialDragState,
    allowDragToCreate,
    defaultDuration,
    isDraggingCreateAnim,
    dragX
  }), [dragStep, allowDragToEdit, isDraggingAnim, isDragging, draggingEvent, dragDuration, dragStartMinutes, draggingId, roundedDragStartMinutes, roundedDragDuration, selectedEvent, dragPosition, dragStartUnix, roundedDragStartUnix, dragSelectedStartUnix, dragSelectedStartMinutes, dragSelectedDuration, isDraggingSelectedEvent, extraMinutes, selectedEventId, dragSelectedType, initialDragState, allowDragToCreate, defaultDuration, isDraggingCreateAnim, dragX]);
  const actionsContext = (0, _react.useMemo)(() => ({
    triggerDragEvent: allowDragToEdit ? triggerDragEvent : undefined,
    triggerDragSelectedEvent,
    triggerDragCreateEvent: allowDragToCreate ? triggerDragCreateEvent : undefined
  }), [allowDragToEdit, triggerDragEvent, triggerDragSelectedEvent, allowDragToCreate, triggerDragCreateEvent]);
  return /*#__PURE__*/_react.default.createElement(DragEventContext.Provider, {
    value: contextValues
  }, /*#__PURE__*/_react.default.createElement(DragEventActionsContext.Provider, {
    value: actionsContext
  }, children));
};
var _default = exports.default = DragEventProvider;
const useDragEvent = () => {
  const context = (0, _react.useContext)(DragEventContext);
  if (!context) {
    throw new Error('useDragEvent must be used within a DragEventProvider');
  }
  return context;
};
exports.useDragEvent = useDragEvent;
const useDragEventActions = () => {
  const context = (0, _react.useContext)(DragEventActionsContext);
  if (!context) {
    throw new Error('useDragEventActions must be used within a DragEventProvider');
  }
  return context;
};
exports.useDragEventActions = useDragEventActions;
//# sourceMappingURL=DragEventProvider.js.map