"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WrapLayoutManager = exports.LayoutManager = void 0;
/**
 * Computes the positions and dimensions of items that will be rendered by the
 * list. The output from this is utilized by viewability tracker to compute the
 * lists of visible/hidden item.
 */

class LayoutManager {
  getOffsetForIndex(index) {
    const layout = this.getLayout(index);
    return {
      x: layout.x,
      y: layout.y
    };
  }

  // You can ovveride this incase you want to override style in some cases e.g, say you want to enfore width but not height
  getStyleOverridesForIndex(_index) {
    return undefined;
  }

  // Return the dimension of entire content inside the list

  // Return all computed layouts as an array, frequently called, you are expected to return a cached array. Don't compute here.

  // Recompute layouts from given index, compute heavy stuff should be here
}
exports.LayoutManager = LayoutManager;
class WrapLayoutManager extends LayoutManager {
  constructor(renderWindowSize) {
    super();
    this._window = renderWindowSize;
    this._totalHeight = 0;
    this._totalWidth = 0;
  }
  getContentDimension() {
    return {
      height: this._totalHeight,
      width: this._totalWidth
    };
  }
  getLayout(index = 0) {
    return {
      x: this._window.width * index,
      y: 0,
      width: this._window.width,
      height: this._window.height
    };
  }
  getOffsetForIndex(index) {
    const layout = this.getLayout(index);
    return {
      x: layout.x,
      y: layout.y
    };
  }
  setMaxBounds(itemDim) {
    itemDim.height = Math.min(this._window.height, itemDim.height);
  }
  relayout(itemCount) {
    this._totalHeight = this._window.height;
    this._totalWidth = itemCount * this._window.width;
  }
}
exports.WrapLayoutManager = WrapLayoutManager;
//# sourceMappingURL=LayoutManager.js.map