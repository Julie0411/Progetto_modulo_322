"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
class ViewabilityTracker {
  constructor(renderAheadOffset, initialOffset, columnsPerPage, extraScrollData) {
    this._currentOffset = Math.max(0, initialOffset);
    this._maxOffset = 0;
    this._actualOffset = 0;
    this._renderAheadOffset = renderAheadOffset;
    this._visibleWindow = {
      start: 0,
      end: 0
    };
    this._engagedWindow = {
      start: 0,
      end: 0
    };
    this._windowBound = 0;
    this._layout = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    this._itemCount = 0;
    this._columnsPerPage = columnsPerPage;
    this._extraScrollData = extraScrollData;
    this._visibleIndexes = []; // needs to be sorted
    this._engagedIndexes = []; // needs to be sorted

    this.onVisibleRowsChanged = null;
    this.onEngagedRowsChanged = null;
    this.onVisibleColumnChanged = null;
  }
  init() {
    this._doInitialFit(this._currentOffset);
  }
  setLayout(layout, maxOffset, itemCount, columnsPerPage, extraScrollData) {
    this._layout = layout;
    this._maxOffset = maxOffset;
    this._itemCount = itemCount;
    this._columnsPerPage = columnsPerPage;
    this._extraScrollData = extraScrollData;
  }
  setDimensions(dimension) {
    this._windowBound = dimension.width;
  }
  forceRefresh() {
    const shouldForceScroll = this._actualOffset >= 0 && this._currentOffset >= this._maxOffset - this._windowBound;
    this.forceRefreshWithOffset(this._currentOffset);
    return shouldForceScroll;
  }
  forceRefreshWithOffset(offset) {
    this._currentOffset = -1;
    this.updateOffset(offset, false);
  }
  updateOffset(offset, isActual) {
    let correctedOffset = offset;
    if (isActual) {
      this._actualOffset = offset;
      correctedOffset = Math.min(this._maxOffset, Math.max(0, offset));
    }
    if (this._currentOffset !== correctedOffset) {
      this._currentOffset = correctedOffset;
      this._updateTrackingWindows(offset);
      let startIndex = 0;
      if (this._visibleIndexes.length > 0) {
        startIndex = this._visibleIndexes[0];
      }
      this._fitAndUpdate(startIndex);
    }
  }
  getLastOffset() {
    return this._currentOffset;
  }
  getLastActualOffset() {
    return this._actualOffset;
  }
  getEngagedIndexes() {
    return this._engagedIndexes;
  }
  updateRenderAheadOffset(renderAheadOffset) {
    this._renderAheadOffset = Math.max(0, renderAheadOffset);
    this.forceRefreshWithOffset(this._currentOffset);
  }
  getCurrentRenderAheadOffset() {
    return this._renderAheadOffset;
  }
  setActualOffset(actualOffset) {
    this._actualOffset = actualOffset;
  }
  _getLayoutByIndex(index = 0) {
    return {
      x: this._layout.width * index,
      y: 0,
      width: this._layout.width,
      height: this._layout.height
    };
  }
  _fitAndUpdate(startIndex) {
    const newVisibleItems = [];
    const newEngagedItems = [];
    this._fitIndexes(newVisibleItems, newEngagedItems, startIndex, true);
    this._fitIndexes(newVisibleItems, newEngagedItems, startIndex + 1, false);
    this._diffUpdateOriginalIndexesAndRaiseEvents(newVisibleItems, newEngagedItems);
  }
  _doInitialFit(offset) {
    offset = Math.min(this._maxOffset, Math.max(0, offset));
    this._updateTrackingWindows(offset);
    const firstVisibleIndex = Math.floor(this._visibleWindow.start / this._layout.width) - 1;
    this._fitAndUpdate(firstVisibleIndex);
  }
  _fitIndexes(newVisibleIndexes, newEngagedIndexes, startIndex, isReverse) {
    const count = this._itemCount;
    const relevantDim = {
      start: 0,
      end: 0
    };
    let i = 0;
    let atLeastOneLocated = false;
    if (startIndex < count) {
      if (!isReverse) {
        for (i = startIndex; i < count; i++) {
          if (this._checkIntersectionAndReport(i, false, relevantDim, newVisibleIndexes, newEngagedIndexes)) {
            atLeastOneLocated = true;
          } else {
            if (atLeastOneLocated) {
              break;
            }
          }
        }
      } else {
        for (i = startIndex; i >= 0; i--) {
          if (this._checkIntersectionAndReport(i, true, relevantDim, newVisibleIndexes, newEngagedIndexes)) {
            atLeastOneLocated = true;
          } else {
            if (atLeastOneLocated) {
              break;
            }
          }
        }
      }
    }
  }
  _checkIntersectionAndReport(index, insertOnTop, relevantDim, newVisibleIndexes, newEngagedIndexes) {
    const itemRect = this._getLayoutByIndex(index);
    let isFound = false;
    this._setRelevantBounds(itemRect, relevantDim);
    if (this._itemIntersectsVisibleWindow(relevantDim.start, relevantDim.end)) {
      if (insertOnTop) {
        newVisibleIndexes.splice(0, 0, index);
        newEngagedIndexes.splice(0, 0, index);
      } else {
        newVisibleIndexes.push(index);
        newEngagedIndexes.push(index);
      }
      isFound = true;
    } else if (this._itemIntersectsEngagedWindow(relevantDim.start, relevantDim.end)) {
      if (insertOnTop) {
        newEngagedIndexes.splice(0, 0, index);
      } else {
        newEngagedIndexes.push(index);
      }
      isFound = true;
    }
    return isFound;
  }
  _setRelevantBounds(itemRect, relevantDim) {
    relevantDim.end = itemRect.x + itemRect.width;
    relevantDim.start = itemRect.x;
  }
  _isItemInBounds(window, itemBound) {
    return window.start < itemBound && window.end > itemBound;
  }
  _isItemBoundsBeyondWindow(window, startBound, endBound) {
    return window.start >= startBound && window.end <= endBound;
  }
  _isZeroHeightEdgeElement(window, startBound, endBound) {
    return startBound - endBound === 0 && (window.start === startBound || window.end === endBound);
  }
  _itemIntersectsWindow(window, startBound, endBound) {
    return this._isItemInBounds(window, startBound) || this._isItemInBounds(window, endBound) || this._isItemBoundsBeyondWindow(window, startBound, endBound) || this._isZeroHeightEdgeElement(window, startBound, endBound);
  }
  _itemIntersectsEngagedWindow(startBound, endBound) {
    return this._itemIntersectsWindow(this._engagedWindow, startBound, endBound);
  }
  _itemIntersectsVisibleWindow(startBound, endBound) {
    return this._itemIntersectsWindow(this._visibleWindow, startBound, endBound);
  }
  _updateTrackingWindows(offset) {
    const startOffset = offset;
    const endOffset = offset + this._windowBound;
    this._engagedWindow.start = Math.max(0, startOffset - this._renderAheadOffset);
    this._engagedWindow.end = endOffset + this._renderAheadOffset;
    this._visibleWindow.start = startOffset;
    this._visibleWindow.end = endOffset;
  }
  _diffUpdateOriginalIndexesAndRaiseEvents(newVisibleItems, newEngagedItems) {
    this._updateAndNotify(newVisibleItems, this._visibleIndexes, this.onVisibleRowsChanged);
    this._updateAndNotify(newEngagedItems, this._engagedIndexes, this.onEngagedRowsChanged);
    if (this.onVisibleColumnChanged && newVisibleItems.length !== 0 && this._columnsPerPage) {
      var _this$_startColumn, _this$_startColumn2;
      const columnWidth = this._windowBound / this._columnsPerPage;
      const startIndex = Math.floor(Math.round(this._currentOffset / columnWidth) / this._columnsPerPage);
      const startOffset = startIndex * this._windowBound;
      const column = Math.round((this._currentOffset - startOffset) / columnWidth);
      if (((_this$_startColumn = this._startColumn) === null || _this$_startColumn === void 0 ? void 0 : _this$_startColumn.index) !== startIndex || ((_this$_startColumn2 = this._startColumn) === null || _this$_startColumn2 === void 0 ? void 0 : _this$_startColumn2.columns) !== column) {
        this.onVisibleColumnChanged({
          index: startIndex,
          columns: this._columnsPerPage,
          column,
          offset: this._currentOffset,
          extraScrollData: this._extraScrollData || {}
        });
        this._startColumn = {
          index: startIndex,
          columns: column
        };
      }
    }
    this._visibleIndexes = newVisibleItems;
    this._engagedIndexes = newEngagedItems;
  }
  _updateAndNotify(newItems, oldItems, callback) {
    if (callback) {
      const {
        now,
        notNow
      } = this._calculateArrayDiff(newItems, oldItems);
      if (now.length > 0 || notNow.length > 0) {
        callback(newItems, now, notNow);
      }
    }
  }
  _calculateArrayDiff(arr1, arr2) {
    const set1 = new Set(arr1);
    const set2 = new Set(arr2);
    const now = arr1.filter(item => !set2.has(item));
    const notNow = arr2.filter(item => !set1.has(item));
    return {
      now,
      notNow
    };
  }
}
exports.default = ViewabilityTracker;
//# sourceMappingURL=ViewabilityTracker.js.map