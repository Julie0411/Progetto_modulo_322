"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _reactNativeReanimated = require("react-native-reanimated");
var _constants = require("./constants");
var _ActionsProvider = _interopRequireDefault(require("./context/ActionsProvider"));
var _CalendarProvider = _interopRequireDefault(require("./context/CalendarProvider"));
var _DragEventProvider = _interopRequireDefault(require("./context/DragEventProvider"));
var _EventsProvider = _interopRequireDefault(require("./context/EventsProvider"));
var _HighlightDatesProvider = _interopRequireDefault(require("./context/HighlightDatesProvider"));
var _LayoutProvider = _interopRequireWildcard(require("./context/LayoutProvider"));
var _LoadingContext = require("./context/LoadingContext");
var _LocaleProvider = _interopRequireDefault(require("./context/LocaleProvider"));
var _NowIndicatorProvider = _interopRequireDefault(require("./context/NowIndicatorProvider"));
var _ThemeProvider = _interopRequireDefault(require("./context/ThemeProvider"));
var _TimeZoneProvider = _interopRequireDefault(require("./context/TimeZoneProvider"));
var _UnavailableHoursProvider = _interopRequireDefault(require("./context/UnavailableHoursProvider"));
var _VisibleDateProvider = _interopRequireDefault(require("./context/VisibleDateProvider"));
var _useLatestCallback = _interopRequireDefault(require("./hooks/useLatestCallback"));
var _useLazyRef = _interopRequireDefault(require("./hooks/useLazyRef"));
var _HapticService = _interopRequireDefault(require("./service/HapticService"));
var _dateUtils = require("./utils/dateUtils");
var _utils = require("./utils/utils");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
const CalendarContainer = ({
  calendarWidth,
  theme,
  children,
  hourWidth: initialHourWidth = _constants.HOUR_WIDTH,
  firstDay = 1,
  minDate = _constants.MIN_DATE,
  maxDate = _constants.MAX_DATE,
  initialDate = _constants.INITIAL_DATE,
  initialLocales,
  locale,
  isLoading = false,
  spaceFromTop = 16,
  spaceFromBottom = 16,
  start = 0,
  end = 1440,
  timeInterval = 60,
  maxTimeIntervalHeight = 124,
  minTimeIntervalHeight = 60,
  allowPinchToZoom = false,
  initialTimeIntervalHeight = 60,
  timeZone: initialTimeZone,
  showWeekNumber = false,
  onChange,
  onDateChanged,
  onPressBackground,
  onPressDayNumber,
  onRefresh,
  unavailableHours,
  highlightDates,
  events,
  onPressEvent,
  numberOfDays: initialNumberOfDays = 7,
  scrollByDay: initialScrollByDay,
  scrollToNow = true,
  useHaptic = false,
  dragStep = 15,
  allowDragToEdit = false,
  onDragEventStart,
  onDragEventEnd,
  onLongPressEvent,
  selectedEvent,
  pagesPerSide = 2,
  hideWeekDays: initialHideWeekDays,
  onDragSelectedEventStart,
  onDragSelectedEventEnd,
  allowDragToCreate = false,
  defaultDuration = 30,
  onDragCreateEventStart,
  onDragCreateEventEnd,
  useAllDayEvent: initialUseAllDayEvent,
  rightEdgeSpacing = 1,
  overlapEventsSpacing = 1,
  minRegularEventMinutes = 1,
  onLoad,
  overlapType,
  minStartDifference,
  onLongPressBackground,
  resources,
  animateColumnWidth = false,
  dragToCreateMode = 'duration'
}, ref) => {
  // TODO: Implement RTL
  const isRTL = false;
  if (initialNumberOfDays > 7) {
    throw new Error('The maximum number of days is 7');
  }
  const isResourceMode = !!resources;
  const scrollByDay = isResourceMode || initialNumberOfDays === 1 || (initialScrollByDay ?? initialNumberOfDays < 7);
  const timeZone = (0, _react.useMemo)(() => {
    const parsedTimeZone = (0, _dateUtils.parseDateTime)(undefined, {
      zone: initialTimeZone
    });
    if (!parsedTimeZone.isValid) {
      console.warn('TimeZone is invalid, using local timeZone');
      return 'local';
    }
    return initialTimeZone || 'local';
  }, [initialTimeZone]);
  const hapticService = (0, _react.useRef)(new _HapticService.default()).current;
  const [hideWeekDays, setHideWeekDays] = (0, _react.useState)(initialHideWeekDays ?? []);
  const hideWeekDaysRef = (0, _react.useRef)(initialHideWeekDays ?? []);
  (0, _react.useEffect)(() => {
    const newHideWeekDays = initialHideWeekDays ?? [];
    if (newHideWeekDays.length === hideWeekDaysRef.current.length) {
      const isSame = newHideWeekDays.every((value, index) => value === hideWeekDaysRef.current[index]);
      if (!isSame) {
        hideWeekDaysRef.current = newHideWeekDays;
        setHideWeekDays(newHideWeekDays);
      }
    } else {
      hideWeekDaysRef.current = newHideWeekDays;
      setHideWeekDays(newHideWeekDays);
    }
  }, [initialHideWeekDays]);
  const useAllDayEvent = isResourceMode ? false : initialUseAllDayEvent ?? true;
  const hideWeekDaysCount = hideWeekDays.length;
  const daysToShow = 7 - hideWeekDaysCount;
  const numberOfDays = isResourceMode ? 1 : initialNumberOfDays > daysToShow ? daysToShow : initialNumberOfDays;
  const isSingleDay = numberOfDays === 1;
  const columns = isSingleDay ? 1 : daysToShow;
  const defaultLayout = (0, _LayoutProvider.useLayout)();
  const calendarLayout = (0, _react.useMemo)(() => {
    return {
      width: calendarWidth ?? defaultLayout.width,
      height: defaultLayout.height
    };
  }, [calendarWidth, defaultLayout.height, defaultLayout.width]);
  const hourWidth = (0, _react.useMemo)(() => _reactNative.PixelRatio.roundToNearestPixel(initialHourWidth), [initialHourWidth]);
  (0, _react.useEffect)(() => {
    hapticService.setEnabled(useHaptic);
  }, [hapticService, useHaptic]);
  const calendarData = (0, _react.useMemo)(() => (0, _utils.prepareCalendarRange)({
    minDate,
    maxDate,
    firstDay,
    isSingleDay,
    hideWeekDays,
    timeZone
  }), [minDate, maxDate, firstDay, isSingleDay, hideWeekDays, timeZone]);
  const slots = (0, _react.useMemo)(() => (0, _utils.calculateSlots)(start, end, timeInterval), [start, end, timeInterval]);
  const totalSlots = slots.length;
  const columnWidth = (calendarLayout.width - hourWidth) / numberOfDays;
  const calendarGridWidth = isSingleDay ? isResourceMode ? calendarLayout.width - hourWidth : calendarLayout.width : columnWidth * columns;
  const calendarListRef = (0, _react.useRef)(null);
  const verticalListRef = (0, _reactNativeReanimated.useAnimatedRef)();
  const dayBarListRef = (0, _reactNativeReanimated.useAnimatedRef)();
  const gridListRef = (0, _reactNativeReanimated.useAnimatedRef)();
  const scrollType = (0, _react.useRef)(_constants.ScrollType.calendarGrid);
  const isTriggerMomentum = (0, _react.useRef)(false);
  const scrollVisibleHeight = (0, _react.useRef)(0);
  const triggerDateChanged = (0, _react.useRef)();

  // Current visible date
  const visibleDateUnix = (0, _useLazyRef.default)(() => {
    const zonedInitialDate = (0, _dateUtils.parseDateTime)(initialDate, {
      zone: timeZone
    }).toISODate();
    let date;
    if (scrollByDay) {
      date = (0, _dateUtils.parseDateTime)(zonedInitialDate);
    } else {
      date = (0, _dateUtils.startOfWeek)(zonedInitialDate, firstDay);
    }
    const dateUnix = date.toMillis();
    return (0, _utils.findNearestNumber)(calendarData.visibleDatesArray, dateUnix);
  });
  const visibleDateUnixAnim = (0, _reactNativeReanimated.useSharedValue)(visibleDateUnix.current);
  const visibleWeeks = (0, _reactNativeReanimated.useSharedValue)([visibleDateUnix.current]);
  const initialOffset = (0, _react.useMemo)(() => {
    const visibleDatesArray = calendarData.visibleDatesArray;
    const visibleDates = calendarData.visibleDates;
    const nearestNumber = (0, _utils.findNearestNumber)(visibleDatesArray, visibleDateUnix.current);
    const nearestDate = visibleDates[nearestNumber];
    if (!nearestDate) {
      return 0;
    }
    const nearestIndex = nearestDate.index;
    if (isSingleDay || scrollByDay) {
      const colWidth = isSingleDay ? calendarGridWidth : columnWidth;
      return nearestIndex * colWidth;
    }
    const pageIndex = Math.floor(nearestIndex / numberOfDays);
    return pageIndex * (columnWidth * numberOfDays);
  }, [numberOfDays, calendarData, calendarGridWidth, columnWidth, isSingleDay, scrollByDay, visibleDateUnix]);
  const columnWidthAnim = (0, _reactNativeReanimated.useSharedValue)(columnWidth);
  const offsetY = (0, _reactNativeReanimated.useSharedValue)(0);
  const offsetX = (0, _reactNativeReanimated.useSharedValue)(initialOffset);
  const scrollVisibleHeightAnim = (0, _reactNativeReanimated.useSharedValue)(0);
  const timeIntervalHeight = (0, _reactNativeReanimated.useSharedValue)(initialTimeIntervalHeight);
  const eventsRef = (0, _react.useRef)(null);
  const extraHeight = spaceFromTop + spaceFromBottom;
  const maxTimelineHeight = totalSlots * maxTimeIntervalHeight + extraHeight;
  const minuteHeight = (0, _reactNativeReanimated.useDerivedValue)(() => timeIntervalHeight.value / timeInterval);
  const timelineHeight = (0, _reactNativeReanimated.useDerivedValue)(() => totalSlots * timeIntervalHeight.value + 1 + extraHeight);
  const startOffset = (0, _reactNativeReanimated.useDerivedValue)(() => start * minuteHeight.value);
  const goToDate = (0, _useLatestCallback.default)(props => {
    const date = (0, _dateUtils.parseDateTime)(props === null || props === void 0 ? void 0 : props.date, {
      zone: timeZone
    });
    const isoDate = date.toISODate();
    let targetDateUnix = (0, _dateUtils.parseDateTime)(isoDate).toMillis();
    if (!scrollByDay) {
      targetDateUnix = (0, _dateUtils.startOfWeek)(isoDate, firstDay).toMillis();
    }
    const visibleDates = calendarData.visibleDatesArray;
    const nearestUnix = (0, _utils.findNearestNumber)(visibleDates, targetDateUnix);
    const visibleDayIndex = visibleDates.indexOf(nearestUnix);
    if (visibleDayIndex !== -1) {
      var _calendarListRef$curr;
      let offset = 0;
      if (isSingleDay || scrollByDay) {
        const colWidth = isSingleDay ? calendarGridWidth : columnWidth;
        offset = visibleDayIndex * colWidth;
      } else {
        const pageIndex = Math.floor(visibleDayIndex / columns);
        offset = pageIndex * (columnWidth * columns);
      }
      const isScrollable = (_calendarListRef$curr = calendarListRef.current) === null || _calendarListRef$curr === void 0 ? void 0 : _calendarListRef$curr.isScrollable(offset, numberOfDays);
      if (isScrollable) {
        triggerDateChanged.current = nearestUnix;
        scrollType.current = _constants.ScrollType.calendarGrid;
        const animatedDate = (props === null || props === void 0 ? void 0 : props.animatedDate) !== undefined ? props.animatedDate : true;
        (0, _reactNativeReanimated.runOnUI)(() => {
          if (_reactNative.Platform.OS === 'web') {
            (0, _reactNativeReanimated.scrollTo)(dayBarListRef, offset, 0, true);
          }
          (0, _reactNativeReanimated.scrollTo)(gridListRef, offset, 0, animatedDate);
        })();
      }
    }
    if (props !== null && props !== void 0 && props.hourScroll) {
      const minutes = date.hour * 60 + date.minute;
      const position = minutes * minuteHeight.value - startOffset.value;
      const scrollOffset = scrollVisibleHeight.current / 2;
      const animatedHour = (props === null || props === void 0 ? void 0 : props.animatedHour) !== undefined ? props.animatedHour : true;
      (0, _reactNativeReanimated.runOnUI)(() => {
        (0, _reactNativeReanimated.scrollTo)(verticalListRef, 0, position - scrollOffset, animatedHour);
      })();
    }
  });
  const goToHour = (0, _useLatestCallback.default)((hour, animated = true) => {
    const timeInMinutes = hour * 60;
    if (timeInMinutes < start || timeInMinutes > end) {
      return;
    }
    const position = (timeInMinutes - start) * minuteHeight.value;
    (0, _reactNativeReanimated.runOnUI)(() => {
      (0, _reactNativeReanimated.scrollTo)(verticalListRef, 0, position, animated);
    })();
  });
  const goToNextPage = (0, _useLatestCallback.default)((animated = true, forceScrollByDay = false) => {
    var _calendarListRef$curr2;
    if (triggerDateChanged.current) {
      return;
    }
    const visibleDatesArray = calendarData.visibleDatesArray;
    const currentIndex = visibleDatesArray.indexOf(visibleDateUnix.current);
    if (currentIndex === -1) {
      return;
    }
    let nextOffset = 0;
    let nextVisibleDayIndex = 0;
    if (isSingleDay || forceScrollByDay || scrollByDay) {
      nextVisibleDayIndex = currentIndex + 1;
      const colWidth = isSingleDay ? calendarGridWidth : columnWidth;
      nextOffset = nextVisibleDayIndex * colWidth;
    } else {
      nextVisibleDayIndex = currentIndex + columns;
      const pageIndex = Math.floor(nextVisibleDayIndex / columns);
      nextOffset = pageIndex * (columnWidth * columns);
    }
    const isScrollable = (_calendarListRef$curr2 = calendarListRef.current) === null || _calendarListRef$curr2 === void 0 ? void 0 : _calendarListRef$curr2.isScrollable(nextOffset, numberOfDays);
    const nextDateUnix = visibleDatesArray[nextVisibleDayIndex];
    if (!nextDateUnix || !isScrollable) {
      triggerDateChanged.current = undefined;
      return;
    }
    triggerDateChanged.current = nextDateUnix;
    scrollType.current = _constants.ScrollType.calendarGrid;
    (0, _reactNativeReanimated.runOnUI)(() => {
      if (_reactNative.Platform.OS === 'web') {
        (0, _reactNativeReanimated.scrollTo)(dayBarListRef, nextOffset, 0, animated);
      }
      (0, _reactNativeReanimated.scrollTo)(gridListRef, nextOffset, 0, animated);
    })();
  });
  const goToPrevPage = (0, _useLatestCallback.default)((animated = true, forceScrollByDay = false) => {
    var _calendarListRef$curr3;
    if (triggerDateChanged.current) {
      return;
    }
    const visibleDatesArray = calendarData.visibleDatesArray;
    const currentIndex = visibleDatesArray.indexOf(visibleDateUnix.current);
    if (currentIndex === -1) {
      return;
    }
    let nextOffset = 0;
    let nextVisibleDayIndex = 0;
    if (isSingleDay || forceScrollByDay || scrollByDay) {
      nextVisibleDayIndex = Math.max(currentIndex - 1, 0);
      const colWidth = isSingleDay ? calendarGridWidth : columnWidth;
      nextOffset = nextVisibleDayIndex * colWidth;
    } else {
      nextVisibleDayIndex = Math.max(currentIndex - columns, 0);
      const pageIndex = Math.floor(nextVisibleDayIndex / columns);
      nextOffset = pageIndex * (columnWidth * columns);
    }
    const isScrollable = (_calendarListRef$curr3 = calendarListRef.current) === null || _calendarListRef$curr3 === void 0 ? void 0 : _calendarListRef$curr3.isScrollable(nextOffset, numberOfDays);
    const nextDateUnix = visibleDatesArray[nextVisibleDayIndex];
    if (!nextDateUnix || !isScrollable) {
      triggerDateChanged.current = undefined;
      return;
    }
    triggerDateChanged.current = nextDateUnix;
    scrollType.current = _constants.ScrollType.calendarGrid;
    (0, _reactNativeReanimated.runOnUI)(() => {
      if (_reactNative.Platform.OS === 'web') {
        (0, _reactNativeReanimated.scrollTo)(dayBarListRef, nextOffset, 0, animated);
      }
      (0, _reactNativeReanimated.scrollTo)(gridListRef, nextOffset, 0, animated);
    })();
  });
  const zoom = (0, _useLatestCallback.default)(props => {
    (0, _reactNativeReanimated.runOnUI)(() => {
      let newHeight = (props === null || props === void 0 ? void 0 : props.height) ?? initialTimeIntervalHeight;
      if (props !== null && props !== void 0 && props.scale) {
        newHeight = timeIntervalHeight.value * props.scale;
      }
      const clampedHeight = (0, _utils.clampValues)(newHeight, minTimeIntervalHeight, maxTimeIntervalHeight);
      const pinchYNormalized = offsetY.value / timeIntervalHeight.value;
      const pinchYScale = clampedHeight * pinchYNormalized;
      const y = pinchYScale;
      timeIntervalHeight.value = (0, _reactNativeReanimated.withTiming)(clampedHeight);
      (0, _reactNativeReanimated.scrollTo)(verticalListRef, 0, y, true);
    })();
  });
  const setVisibleDate = (0, _useLatestCallback.default)(initDate => {
    const dateObj = (0, _dateUtils.parseDateTime)(initDate, {
      zone: timeZone
    });
    const isoDate = dateObj.toISODate();
    const targetDateUnix = (0, _dateUtils.parseDateTime)(isoDate).toMillis();
    const visibleDates = calendarData.visibleDatesArray;
    const nearestUnix = (0, _utils.findNearestNumber)(visibleDates, targetDateUnix);
    visibleDateUnix.current = nearestUnix;
    visibleDateUnixAnim.value = nearestUnix;
  });
  const getDateByOffset = (0, _useLatestCallback.default)(position => {
    const visibleDatesArray = calendarData.visibleDatesArray;
    const dayIndex = visibleDatesArray.indexOf(visibleDateUnix.current);
    if (dayIndex === -1) {
      return;
    }
    const columnIndex = Math.floor(position.x / columnWidth);
    const dateUnixByIndex = calendarData.visibleDatesArray[dayIndex + columnIndex];
    if (!dateUnixByIndex) {
      return;
    }
    const minutes = Math.floor(position.y / minuteHeight.value) + start;
    return (0, _dateUtils.parseDateTime)(dateUnixByIndex).plus({
      minutes
    });
  });
  const getDateStringByOffset = (0, _useLatestCallback.default)(position => {
    const date = getDateByOffset(position);
    if (!date) {
      return null;
    }
    const dateObj = (0, _dateUtils.forceUpdateZone)(date, timeZone);
    return (0, _dateUtils.dateTimeToISOString)(dateObj);
  });
  const getEventByOffset = (0, _useLatestCallback.default)(position => {
    var _eventsRef$current;
    const date = getDateByOffset(position);
    if (!date) {
      return null;
    }
    const columnIndex = Math.floor(position.x / columnWidth);
    const dateString = (0, _dateUtils.dateTimeToISOString)(date);
    const eventsByDate = ((_eventsRef$current = eventsRef.current) === null || _eventsRef$current === void 0 ? void 0 : _eventsRef$current.getEventsByDate(dateString)) ?? [];
    for (let i = 0; i < eventsByDate.length; i++) {
      const event = eventsByDate[i];
      let eventX = 0;
      let eventWidth = 0;
      const {
        total,
        index,
        xOffsetPercentage,
        widthPercentage
      } = event._internal;
      if (xOffsetPercentage && widthPercentage) {
        eventWidth = columnWidth * widthPercentage;
        eventX = columnWidth * xOffsetPercentage;
      } else if (total && index) {
        eventWidth = columnWidth / total;
        eventX = index * eventWidth;
      }
      const targetX = position.x - columnIndex * columnWidth;
      if (targetX >= eventX && targetX <= eventX + eventWidth) {
        const clonedEvent = {
          ...event
        };
        delete clonedEvent._internal;
        return clonedEvent;
      }
    }
    return null;
  });
  const getSizeByDuration = (0, _useLatestCallback.default)(duration => {
    const height = duration * minuteHeight.value;
    return {
      width: columnWidth,
      height
    };
  });
  const getVisibleStart = (0, _useLatestCallback.default)(() => {
    const currentDate = (0, _dateUtils.forceUpdateZone)(visibleDateUnix.current, timeZone);
    const startMinutes = offsetY.value / minuteHeight.value - start;
    currentDate.plus({
      minutes: startMinutes
    });
    return (0, _dateUtils.dateTimeToISOString)(currentDate);
  });
  const getCurrentOffsetY = (0, _useLatestCallback.default)(() => {
    return offsetY.value;
  });
  (0, _react.useImperativeHandle)(ref, () => ({
    goToDate,
    goToHour,
    goToNextPage,
    goToPrevPage,
    zoom,
    setVisibleDate,
    getDateByOffset: getDateStringByOffset,
    getEventByOffset,
    getSizeByDuration,
    getVisibleStart,
    getCurrentOffsetY
  }), [getDateStringByOffset, getEventByOffset, getSizeByDuration, goToDate, goToHour, goToNextPage, goToPrevPage, setVisibleDate, zoom, getVisibleStart, getCurrentOffsetY]);
  const prevMode = (0, _react.useRef)(isSingleDay);
  (0, _react.useEffect)(() => {
    if (!animateColumnWidth) {
      columnWidthAnim.value = columnWidth;
      return;
    }
    if (prevMode.current !== isSingleDay) {
      prevMode.current = isSingleDay;
      columnWidthAnim.value = columnWidth;
    } else {
      columnWidthAnim.value = (0, _reactNativeReanimated.withTiming)(columnWidth);
    }
  }, [columnWidthAnim, columnWidth, isSingleDay, animateColumnWidth]);
  const snapToInterval = numberOfDays > 1 && scrollByDay && !isResourceMode ? columnWidth : undefined;
  const value = (0, _react.useMemo)(() => ({
    calendarLayout,
    hourWidth,
    calendarData,
    numberOfDays,
    visibleDateUnix,
    verticalListRef,
    dayBarListRef,
    gridListRef,
    columnWidthAnim,
    firstDay,
    scrollType,
    offsetY,
    minuteHeight,
    maxTimelineHeight,
    maxTimeIntervalHeight,
    minTimeIntervalHeight,
    timeIntervalHeight,
    allowPinchToZoom,
    spaceFromTop,
    spaceFromBottom,
    timelineHeight,
    slots,
    totalSlots,
    start,
    end,
    timeInterval,
    scrollVisibleHeight,
    offsetX,
    isTriggerMomentum,
    showWeekNumber,
    calendarGridWidth,
    columnWidth,
    scrollByDay,
    initialOffset,
    isRTL,
    snapToInterval,
    columns,
    triggerDateChanged,
    visibleDateUnixAnim,
    calendarListRef,
    startOffset,
    scrollVisibleHeightAnim,
    pagesPerSide,
    hideWeekDays,
    visibleWeeks,
    useAllDayEvent,
    hapticService,
    rightEdgeSpacing,
    overlapEventsSpacing,
    allowDragToCreate,
    allowDragToEdit,
    dragToCreateMode
  }), [calendarLayout, hourWidth, calendarData, numberOfDays, visibleDateUnix, verticalListRef, dayBarListRef, gridListRef, columnWidthAnim, firstDay, offsetY, minuteHeight, maxTimelineHeight, maxTimeIntervalHeight, minTimeIntervalHeight, timeIntervalHeight, allowPinchToZoom, spaceFromTop, spaceFromBottom, timelineHeight, slots, totalSlots, start, end, timeInterval, offsetX, showWeekNumber, calendarGridWidth, columnWidth, scrollByDay, initialOffset, isRTL, snapToInterval, columns, visibleDateUnixAnim, startOffset, scrollVisibleHeightAnim, pagesPerSide, hideWeekDays, visibleWeeks, useAllDayEvent, hapticService, rightEdgeSpacing, overlapEventsSpacing, allowDragToCreate, allowDragToEdit, dragToCreateMode]);
  const _onLoad = (0, _useLatestCallback.default)(() => {
    if (scrollToNow) {
      goToDate({
        hourScroll: true,
        animatedHour: true
      });
    }
    onLoad === null || onLoad === void 0 || onLoad();
  });
  const actionsProps = {
    onPressBackground,
    onPressDayNumber,
    onRefresh,
    onChange,
    onDateChanged,
    onPressEvent,
    onDragEventStart,
    onDragEventEnd,
    onLongPressEvent,
    onDragSelectedEventStart,
    onDragSelectedEventEnd,
    onDragCreateEventStart,
    onDragCreateEventEnd,
    onLoad: _onLoad,
    onLongPressBackground
  };
  const loadingValue = (0, _react.useMemo)(() => ({
    isLoading
  }), [isLoading]);
  return /*#__PURE__*/_react.default.createElement(_CalendarProvider.default, {
    value: value
  }, /*#__PURE__*/_react.default.createElement(_LocaleProvider.default, {
    initialLocales: initialLocales,
    locale: locale
  }, /*#__PURE__*/_react.default.createElement(_TimeZoneProvider.default, {
    timeZone: timeZone
  }, /*#__PURE__*/_react.default.createElement(_NowIndicatorProvider.default, null, /*#__PURE__*/_react.default.createElement(_ThemeProvider.default, {
    theme: theme
  }, /*#__PURE__*/_react.default.createElement(_ActionsProvider.default, actionsProps, /*#__PURE__*/_react.default.createElement(_LoadingContext.LoadingContext.Provider, {
    value: loadingValue
  }, /*#__PURE__*/_react.default.createElement(_VisibleDateProvider.default, {
    initialStart: visibleDateUnix
  }, /*#__PURE__*/_react.default.createElement(_HighlightDatesProvider.default, {
    highlightDates: highlightDates
  }, /*#__PURE__*/_react.default.createElement(_UnavailableHoursProvider.default, {
    unavailableHours: unavailableHours,
    timeZone: timeZone,
    pagesPerSide: pagesPerSide
  }, /*#__PURE__*/_react.default.createElement(_EventsProvider.default, {
    ref: eventsRef,
    events: events,
    firstDay: firstDay,
    timeZone: timeZone,
    useAllDayEvent: useAllDayEvent,
    pagesPerSide: pagesPerSide,
    minRegularEventMinutes: minRegularEventMinutes,
    hideWeekDays: hideWeekDays,
    overlapType: overlapType,
    resources: resources,
    minStartDifference: minStartDifference
  }, /*#__PURE__*/_react.default.createElement(_DragEventProvider.default, {
    dragStep: dragStep,
    allowDragToEdit: allowDragToEdit,
    selectedEvent: selectedEvent,
    allowDragToCreate: allowDragToCreate,
    defaultDuration: defaultDuration,
    resources: resources,
    hapticService: hapticService
  }, children))))))))))));
};
const CalendarContainerInner = /*#__PURE__*/(0, _react.forwardRef)(CalendarContainer);
const CalendarContainerWithLayout = (props, ref) => {
  return /*#__PURE__*/_react.default.createElement(_LayoutProvider.default, null, /*#__PURE__*/_react.default.createElement(CalendarContainerInner, _extends({}, props, {
    ref: ref
  })));
};
var _default = exports.default = /*#__PURE__*/(0, _react.forwardRef)(CalendarContainerWithLayout);
//# sourceMappingURL=CalendarContainer.js.map