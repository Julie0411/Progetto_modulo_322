"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = _interopRequireDefault(require("lodash.isequal"));
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _reactNativeReanimated = _interopRequireWildcard(require("react-native-reanimated"));
var _constants = require("../constants");
var _BodyContext = require("../context/BodyContext");
var _ThemeProvider = require("../context/ThemeProvider");
var _Text = _interopRequireDefault(require("./Text"));
var _dateUtils = require("../utils/dateUtils");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const EventItem = ({
  event: eventInput,
  startUnix,
  renderEvent,
  onPressEvent,
  onLongPressEvent,
  isDragging,
  visibleDates,
  totalResources
}) => {
  const theme = (0, _ThemeProvider.useTheme)((0, _react.useCallback)(state => {
    return {
      eventContainerStyle: state.eventContainerStyle,
      eventTitleStyle: state.eventTitleStyle
    };
  }, []));
  const {
    minuteHeight,
    columnWidthAnim,
    start,
    end,
    rightEdgeSpacing,
    overlapEventsSpacing,
    columnWidth
  } = (0, _BodyContext.useBody)();
  const {
    _internal,
    ...event
  } = eventInput;
  const {
    duration,
    startMinutes = 0,
    total,
    index,
    columnSpan,
    startUnix: eventStartUnix,
    widthPercentage,
    xOffsetPercentage,
    resourceIndex
  } = _internal;
  const data = (0, _react.useMemo)(() => {
    const maxDuration = end - start;
    let newStart = startMinutes - start;
    let totalDuration = Math.min(duration, maxDuration);
    if (newStart < 0) {
      totalDuration += newStart;
      newStart = 0;
    }
    let diffDays = Math.floor((eventStartUnix - startUnix) / _constants.MILLISECONDS_IN_DAY);
    if (eventStartUnix < startUnix) {
      for (let dayUnix = eventStartUnix; dayUnix < startUnix; dayUnix = (0, _dateUtils.parseDateTime)(dayUnix).plus({
        days: 1
      }).toMillis()) {
        const dayStartUnix = (0, _dateUtils.parseDateTime)(dayUnix).startOf('day').toMillis();
        if (!visibleDates[dayStartUnix]) {
          diffDays++;
        }
      }
    } else {
      for (let dayUnix = startUnix; dayUnix < eventStartUnix; dayUnix = (0, _dateUtils.parseDateTime)(dayUnix).plus({
        days: 1
      }).toMillis()) {
        const dayStartUnix = (0, _dateUtils.parseDateTime)(dayUnix).startOf('day').toMillis();
        if (!visibleDates[dayStartUnix]) {
          diffDays--;
        }
      }
    }
    return {
      totalDuration,
      startMinutes: newStart,
      diffDays
    };
  }, [duration, end, eventStartUnix, start, startMinutes, startUnix, visibleDates]);
  const childColumns = totalResources && totalResources > 0 ? totalResources : 1;
  const eventHeight = (0, _reactNativeReanimated.useDerivedValue)(() => data.totalDuration * minuteHeight.value - 1, [data.totalDuration]);
  const widthPercent = (0, _reactNativeReanimated.useDerivedValue)(() => {
    if (total && columnSpan) {
      const availableWidth = columnWidth / childColumns - rightEdgeSpacing;
      const totalColumns = total - columnSpan;
      const overlapSpacing = totalColumns * overlapEventsSpacing / total;
      const eventWidth = availableWidth / total * columnSpan - overlapSpacing;
      const percent = eventWidth / availableWidth;
      return (0, _reactNativeReanimated.withTiming)(percent, {
        duration: 150
      });
    }
    const basePercent = widthPercentage ? widthPercentage / 100 : 1;
    return (0, _reactNativeReanimated.withTiming)(basePercent, {
      duration: 150
    });
  }, [widthPercentage, columnSpan, rightEdgeSpacing, overlapEventsSpacing, total, columnWidth, childColumns]);
  const eventWidth = (0, _reactNativeReanimated.useDerivedValue)(() => {
    const availableWidth = columnWidthAnim.value / childColumns - rightEdgeSpacing;
    return widthPercent.value * availableWidth;
  }, [childColumns, columnSpan, rightEdgeSpacing, overlapEventsSpacing, total, widthPercentage]);
  const eventPosX = (0, _reactNativeReanimated.useDerivedValue)(() => {
    const colWidth = columnWidthAnim.value / childColumns;
    const startOffset = resourceIndex ? resourceIndex * colWidth : 0;
    let left = data.diffDays * colWidth + startOffset;
    if (xOffsetPercentage) {
      const availableWidth = columnWidthAnim.value / childColumns - rightEdgeSpacing;
      left += availableWidth * (xOffsetPercentage / 100);
    } else if (columnSpan && index) {
      left += (eventWidth.value + overlapEventsSpacing) * (index / columnSpan);
    }
    return left;
  }, [childColumns, data.diffDays, overlapEventsSpacing, rightEdgeSpacing, index, total, xOffsetPercentage, resourceIndex]);
  const top = (0, _reactNativeReanimated.useDerivedValue)(() => {
    return data.startMinutes * minuteHeight.value;
  }, [data.startMinutes]);
  const animView = (0, _reactNativeReanimated.useAnimatedStyle)(() => {
    return {
      height: eventHeight.value,
      width: eventWidth.value,
      left: eventPosX.value + 1,
      top: top.value + 1
    };
  });
  const _onPressEvent = () => {
    if (onPressEvent) {
      onPressEvent(eventInput);
    }
  };
  const _onLongPressEvent = resEvent => {
    onLongPressEvent(eventInput, resEvent);
  };
  const opacity = isDragging ? 0.5 : 1;
  return /*#__PURE__*/_react.default.createElement(_reactNativeReanimated.default.View, {
    style: [styles.container, animView]
  }, /*#__PURE__*/_react.default.createElement(_reactNative.TouchableOpacity, {
    style: _reactNative.StyleSheet.absoluteFill,
    activeOpacity: 0.6,
    disabled: !onPressEvent && !onLongPressEvent,
    onPress: onPressEvent ? _onPressEvent : undefined,
    onLongPress: onLongPressEvent ? _onLongPressEvent : undefined
  }, /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [styles.contentContainer, !!xOffsetPercentage && styles.overlapEvent, {
      backgroundColor: event.color
    }, theme.eventContainerStyle, {
      opacity
    }]
  }, renderEvent ? renderEvent(eventInput, {
    width: eventWidth,
    height: eventHeight
  }) : /*#__PURE__*/_react.default.createElement(_Text.default, {
    style: [styles.title, theme.eventTitleStyle]
  }, event.title))));
};
var _default = exports.default = /*#__PURE__*/_react.default.memo(EventItem, (prev, next) => {
  return (0, _lodash.default)(prev.event, next.event) && (0, _lodash.default)(prev.visibleDates, next.visibleDates) && prev.startUnix === next.startUnix && prev.renderEvent === next.renderEvent && prev.isDragging === next.isDragging && prev.onPressEvent === next.onPressEvent && prev.onLongPressEvent === next.onLongPressEvent;
});
const styles = _reactNative.StyleSheet.create({
  container: {
    position: 'absolute',
    overflow: 'hidden'
  },
  title: {
    fontSize: 12,
    paddingHorizontal: 2
  },
  contentContainer: {
    borderRadius: 2,
    width: '100%',
    height: '100%',
    overflow: 'hidden'
  },
  overlapEvent: {
    borderWidth: 1,
    borderColor: '#FFF'
  }
});
//# sourceMappingURL=EventItem.js.map