import React, { createContext, useCallback, useContext, useEffect } from 'react';
import useLazyRef from '../hooks/useLazyRef';
import { useSyncExternalStoreWithSelector } from '../hooks/useSyncExternalStoreWithSelector';
import { createStore } from '../storeBuilder';
import { forceUpdateZone, parseDateTime } from '../utils/dateUtils';
import { useDateChangedListener } from './VisibleDateProvider';
export const UnavailableHoursContext = /*#__PURE__*/createContext(undefined);
const UnavailableHoursProvider = ({
  children,
  unavailableHours = {},
  timeZone,
  pagesPerSide
}) => {
  const unavailableHoursStore = useLazyRef(() => createStore({
    unavailableHours: {}
  })).current;
  const currentDate = useDateChangedListener();
  const notifyDataChanged = useCallback((date, offset = 7) => {
    let originalData = {};
    if (Array.isArray(unavailableHours)) {
      originalData = {
        '1': unavailableHours,
        '2': unavailableHours,
        '3': unavailableHours,
        '4': unavailableHours,
        '5': unavailableHours,
        '6': unavailableHours,
        '7': unavailableHours
      };
    } else {
      originalData = unavailableHours;
    }
    const data = {};
    // Iterate over the date range
    let startDateTime = parseDateTime(date).minus({
      days: offset * pagesPerSide
    });
    const endDateTime = parseDateTime(date).plus({
      days: offset * (pagesPerSide + 1)
    });
    while (startDateTime <= endDateTime) {
      const forceDate = forceUpdateZone(startDateTime, timeZone);
      const dateUnix = forceDate.toMillis();
      const weekDay = forceDate.weekday;
      const dateStr = forceDate.toFormat('yyyy-MM-dd');

      // Get unavailable hours either by specific date or by weekday
      const unavailableHoursByDate = originalData[dateStr] || originalData[weekDay];

      // If unavailable hours are found for this day, store them
      if (unavailableHoursByDate) {
        data[dateUnix] = unavailableHoursByDate;
      }

      // Move to the next day
      startDateTime = startDateTime.plus({
        days: 1
      });
    }
    unavailableHoursStore.setState({
      unavailableHours: data
    });
  }, [unavailableHours, pagesPerSide, timeZone, unavailableHoursStore]);
  useEffect(() => {
    notifyDataChanged(currentDate);
  }, [currentDate, notifyDataChanged]);
  return /*#__PURE__*/React.createElement(UnavailableHoursContext.Provider, {
    value: unavailableHoursStore
  }, children);
};
export default UnavailableHoursProvider;
const selector = state => state.unavailableHours || {};
export const useUnavailableHours = () => {
  const unavailableHoursContext = useContext(UnavailableHoursContext);
  if (!unavailableHoursContext) {
    throw new Error('useRegionsByDate must be used within a UnavailableHoursProvider');
  }
  const state = useSyncExternalStoreWithSelector(unavailableHoursContext.subscribe, unavailableHoursContext.getState, selector);
  return state;
};
export const useUnavailableHoursByDate = dateUnix => {
  const unavailableHoursContext = useContext(UnavailableHoursContext);
  if (!unavailableHoursContext) {
    throw new Error('useRegionsByDate must be used within a UnavailableHoursProvider');
  }
  const selectUnavailableHoursByDate = useCallback(state => {
    return state.unavailableHours ? state.unavailableHours[dateUnix] : undefined;
  }, [dateUnix]);
  const state = useSyncExternalStoreWithSelector(unavailableHoursContext.subscribe, unavailableHoursContext.getState, selectUnavailableHoursByDate);
  return state;
};
//# sourceMappingURL=UnavailableHoursProvider.js.map