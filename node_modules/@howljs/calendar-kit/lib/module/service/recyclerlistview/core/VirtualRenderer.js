import RecycleItemPool from '../utils/RecycleItemPool';
import { isNullOrUndefined, valueWithDefault } from '../utils/utils';
import ViewabilityTracker from './ViewabilityTracker';

/**
 * Renderer which keeps track of recyclable items and the currently rendered
 * items. Notifies list view to re render if something changes, like scroll
 * offset
 */

export default class VirtualRenderer {
  _layoutManager = null;
  _viewabilityTracker = null;
  constructor(renderStackChanged, scrollOnNextUpdate) {
    // Keeps track of items that need to be rendered in the next render cycle
    this._renderStack = {};

    // Keeps track of keys of all the currently rendered indexes, can eventually replace renderStack as well if no new use cases come up
    this._stableIdToRenderKeyMap = {};
    this._engagedIndexes = {};
    this._renderStackChanged = renderStackChanged;
    this._scrollOnNextUpdate = scrollOnNextUpdate;
    this._dimensions = null;
    this._params = null;
    this._isViewTrackerRunning = false;
    this._markDirty = false;

    // Would be surprised if someone exceeds this
    this._startKey = 0;
    this.onVisibleItemsChanged = null;
    this.onVisibleColumnChanged = null;
  }
  getLayoutDimension() {
    if (this._layoutManager) {
      return this._layoutManager.getContentDimension();
    }
    return {
      height: 0,
      width: 0
    };
  }
  updateOffset(offsetX, isActual) {
    if (this._viewabilityTracker) {
      const offset = offsetX;
      if (!this._isViewTrackerRunning) {
        if (isActual) {
          this._viewabilityTracker.setActualOffset(offset);
        }
        this.startViewabilityTracker();
      }
      this._viewabilityTracker.updateOffset(offset, isActual);
    }
  }
  attachVisibleItemsListener(callback) {
    this.onVisibleItemsChanged = callback;
  }
  removeVisibleItemsListener() {
    this.onVisibleItemsChanged = null;
    if (this._viewabilityTracker) {
      this._viewabilityTracker.onVisibleRowsChanged = null;
    }
  }
  attachVisibleColumnsListener(callback) {
    this.onVisibleColumnChanged = callback;
  }
  removeVisibleColumnsListener() {
    this.onVisibleColumnChanged = null;
    if (this._viewabilityTracker) {
      this._viewabilityTracker.onVisibleColumnChanged = null;
    }
  }
  getLayoutManager() {
    return this._layoutManager;
  }
  setParamsAndDimensions(params, dim) {
    this._params = params;
    this._dimensions = dim;
  }
  setLayoutManager(layoutManager) {
    this._layoutManager = layoutManager;
    if (this._params) {
      this._layoutManager.relayout(this._params.itemCount);
    }
  }
  getViewabilityTracker() {
    return this._viewabilityTracker;
  }
  refreshWithOffset(offset) {
    if (this._viewabilityTracker) {
      this._prepareViewabilityTracker();
      this._scrollOnNextUpdate({
        x: offset,
        y: 0
      });
      this._viewabilityTracker.forceRefreshWithOffset(offset);
    }
  }
  refresh() {
    if (this._viewabilityTracker) {
      this._prepareViewabilityTracker();
      this._viewabilityTracker.forceRefresh();
    }
  }
  getInitialOffset() {
    const offset = {
      x: 0,
      y: 0
    };
    if (this._params) {
      offset.x = valueWithDefault(this._params.initialOffset, 0);
      offset.y = 0;
    }
    return offset;
  }
  init() {
    this.getInitialOffset();
    this._recyclePool = new RecycleItemPool();
    if (this._params) {
      this._viewabilityTracker = new ViewabilityTracker(valueWithDefault(this._params.renderAheadOffset, 0), valueWithDefault(this._params.initialOffset, 0), this._params.columnsPerPage, this._params.extraScrollData);
    } else {
      this._viewabilityTracker = new ViewabilityTracker(0, 0);
    }
    this._prepareViewabilityTracker();
  }
  startViewabilityTracker() {
    if (this._viewabilityTracker) {
      this._isViewTrackerRunning = true;
      this._viewabilityTracker.init();
    }
  }
  syncAndGetKey(index) {
    const renderStack = this._renderStack;
    const stableIdItem = this._stableIdToRenderKeyMap[index];
    let key = stableIdItem ? stableIdItem.key : undefined;
    if (isNullOrUndefined(key)) {
      var _this$_recyclePool;
      key = (_this$_recyclePool = this._recyclePool) === null || _this$_recyclePool === void 0 ? void 0 : _this$_recyclePool.getRecycledObject();
      if (!isNullOrUndefined(key)) {
        const itemMeta = renderStack[key];
        if (itemMeta) {
          const oldIndex = itemMeta.dataIndex;
          itemMeta.dataIndex = index;
          if (!isNullOrUndefined(oldIndex) && oldIndex !== index) {
            delete this._stableIdToRenderKeyMap[oldIndex];
          }
        } else {
          renderStack[key] = {
            dataIndex: index
          };
        }
      } else {
        key = `${index}`;
        if (renderStack[key]) {
          key = this._getCollisionAvoidingKey();
        }
        renderStack[key] = {
          dataIndex: index
        };
      }
      this._markDirty = true;
      this._stableIdToRenderKeyMap[index] = {
        key
      };
    }
    if (!isNullOrUndefined(this._engagedIndexes[index])) {
      var _this$_recyclePool2;
      (_this$_recyclePool2 = this._recyclePool) === null || _this$_recyclePool2 === void 0 || _this$_recyclePool2.removeFromPool(key);
    }
    const stackItem = renderStack[key];
    if (stackItem && stackItem.dataIndex !== index) {
      // Probable collision, warn
      console.warn('Possible stableId collision @', index); // tslint:disable-line
    }
    return key;
  }
  _getCollisionAvoidingKey() {
    return '#' + this._startKey++ + '_rlv_c';
  }
  _prepareViewabilityTracker() {
    if (this._viewabilityTracker && this._layoutManager && this._dimensions && this._params) {
      this._viewabilityTracker.onEngagedRowsChanged = this._onEngagedItemsChanged;
      if (this.onVisibleItemsChanged) {
        this._viewabilityTracker.onVisibleRowsChanged = this._onVisibleItemsChanged;
      }
      if (this.onVisibleColumnChanged) {
        this._viewabilityTracker.onVisibleColumnChanged = this._onVisibleColumnChanged;
      }
      this._viewabilityTracker.setLayout(this._layoutManager.getLayout(), this._layoutManager.getContentDimension().width, this._params.itemCount, this._params.columnsPerPage, this._params.extraScrollData);
      this._viewabilityTracker.setDimensions({
        height: this._dimensions.height,
        width: this._dimensions.width
      });
    } else {
      throw new Error('Parameters required for initializing the module are missing');
    }
  }
  _onVisibleItemsChanged = (all, now, notNow) => {
    if (this.onVisibleItemsChanged) {
      this.onVisibleItemsChanged(all, now, notNow);
    }
  };
  _onVisibleColumnChanged = props => {
    if (this.onVisibleColumnChanged) {
      this.onVisibleColumnChanged(props);
    }
  };
  _onEngagedItemsChanged = (_all, now, notNow) => {
    const count = notNow.length;
    let resolvedKey;
    let disengagedIndex = 0;
    for (let i = 0; i < count; i++) {
      disengagedIndex = notNow[i];
      delete this._engagedIndexes[disengagedIndex];
      if (this._params && disengagedIndex < this._params.itemCount) {
        // All the items which are now not visible can go to the recycle pool, the pool only needs to maintain keys since
        // react can link a view to a key automatically
        resolvedKey = this._stableIdToRenderKeyMap[disengagedIndex];
        if (!isNullOrUndefined(resolvedKey)) {
          var _this$_recyclePool3;
          (_this$_recyclePool3 = this._recyclePool) === null || _this$_recyclePool3 === void 0 || _this$_recyclePool3.putRecycledObject(resolvedKey.key);
        }
      }
    }
    if (this._updateRenderStack(now)) {
      // Ask Recycler View to update itself
      this._renderStackChanged(this._renderStack);
    }
  };

  // Updates render stack and reports whether anything has changed
  _updateRenderStack(itemIndexes) {
    this._markDirty = false;
    const count = itemIndexes.length;
    let index = 0;
    let hasRenderStackChanged = false;
    for (let i = 0; i < count; i++) {
      index = itemIndexes[i];
      this._engagedIndexes[index] = 1;
      this.syncAndGetKey(index);
      hasRenderStackChanged = this._markDirty;
    }
    this._markDirty = false;
    return hasRenderStackChanged;
  }
}
//# sourceMappingURL=VirtualRenderer.js.map